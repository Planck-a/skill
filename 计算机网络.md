计算机网络
===
`重点是ip、tcp、http`

网络层（IP）
--
1、ip数据报格式
![示意图]（https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.png）

版本：指IP协议的版本，4或者6

首部长度：固定字节部分和可变部分的总长度（不包含数据部分）

区分服务：服务类型（实际没有用到）

总长度：首部和数据之和，最大为65535字节（超过则需要切片）

标识：表示分片后的同一数据

标志：三位（起作用的是两位）一是MF（1表示“还有分片”，0表示“最后一个”）二是DF（DF=0时允许分片）

片偏移：表示当前数据报在元数据中的位置

生存时间（TTL）：可通过路由器数（跳数）的最大值，没经过一个-1，为0时丢弃

协议：当前数据报应该由哪一个上层协议进行处理

首部校验和：只针对于首部信息完整性的校验

源地址和目的地址：字面意思




2 ip地址划分
![示意图1](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.png)
![示意图2](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.png)

IP地址由两部分组成，网络号和主机号。
```cpp
子网掩码255.0.0.0     A类地址         第一段8位为网络位 后3段为主机位。
子网掩码255.255.0.0   那就是B类地址   主机位和网络位各为两段。 
子网掩码255.255.255.0 那就是C类地址   网络位3段 主机位一段。
```
```cpp
类型   范围    网络位    主机位
A类   0~126     8位       24位   1.0.0.0---126.0.0.0
     (127.X.X.X是保留地址，用做循环测试用的)
B类   128~191  16位       16位   128.0.0.0---191.255.0.0
C类   192~223  24位       8位    192.0.0.0---223.255.255.0
D类   224~239  组播地址           224.0.0.0---239.255.255.255
```
3、网际控制报文协议 ICMP
`ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。`

ICMP 报文分为差错报告报文和询问报文。

(1) Ping

Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

(2)Traceroute

Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。

Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。

源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；

源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。

不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。

之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。


4、常见的路由协议

* 路由协议有静态路由和动态路由

  静态协议：网络管理员自己可以编辑
  
  动态路由：针对复杂的网段，经常有变化的，需要路由器自己学习 RIP和OSPF
  
* 常见的路由协议：	RIP、IGRP（Cisco私有协议）、EIGRP（Cisco私有协议）、OSPF

* RIP
1.周期性广播自己的路由表,30秒      路由1-------->路由2------->路由3

2.跳数是最佳路径的标准，只记录最佳路径

3.最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达

* OSPF：
1、不周期更新，每隔10秒发一个hello包，避免大量的数据传输（比如一个路由器连100个，那每30秒就要传一次）=====》生成邻居表

2、交换邻居表=====》链路状态表，利用迪杰斯特拉算法，算出最佳路径

3、最佳路径度量值是带宽

4.分区域进行最佳路径的计算，河北区，山西区等

传输层（TCP/UDP）
---
 1、描述TCP头部？

* 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。

* 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1；第一次收到1024，确认号为1025。

* 首部长（4bit）：标识首部长度0~15，一个长度代表4字节，最大为15，即60字节。

* 标志位（6bit）：

    URG：标志紧急指针是否有效。

    ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。

    PSH：提示接收端立即从缓冲读走数据。

    RST：表示要求对方重新建立连接（复位报文段）。

    SYN：表示请求建立一个连接（连接报文段）。

    FIN：表示关闭连接（断开报文段）。

* 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。

* 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。

 2、三次握手和四次挥手过程？
![示意图](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clipboard.png)
三次握手：客户端发起连接请求，SYN=1表示连接请求，随机的序列号SEQ_NUM=s；服务器收到后向客户端回复，发送确认包ACK=1,ACK_NUM=S+1,随机的序列号SEQ_NUM=q；客户端第三次回复ACK=1，ACK_NUM=q+1；

四次挥手：客户机发含FIN位，SEQ = Q的包到服务器。第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器，此处有等待。第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机，有等待。第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -> CLOSED）

3、FIN_WAIT_2，CLOSE_WAIT状态？

服务器在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否可以断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，要先等待服务器的数据包发送，在发送FIN包之前服务器均为CLOSE_WAIT，客户端为FIN_WAIT_2。等数据发送完毕，服务器发送第三次挥手，客户端收到FIN后，状态FIN_WAIT_2结束。

4、主动结束连接的一方为什么要等待2MSL，TIMEWAIT？

A<-------B(B发FIN到A，第三次握手)

A------->B（A发ack到B，第四次握手）

为了防止第四次挥手没有正常达到对方，假如ACK没有到达B，B会为FIN这个消息超时重传,那如果A等待时间足够,又收到FIN消息,说明ACK没有到达B，于是再发送ACK，知道在足够的时间内没有收到FIN，说明ACK成功到达。

`过多的timewait有什么影响？`
答： 在`高并发短连接`的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时其他想连服务器的客户端就会显示连接不上。原因是：

1、高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了。

2、在这个场景中，短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接

3、这里有个相对长短的概念，比如取一个web页面，1秒钟的http短连接处理完业务，在关闭连接之后，这个业务用过的端口会停留在TIMEWAIT状态几分钟，而这几分钟，其他HTTP请求来临的时候是无法占用此端口的(占着茅坑不拉翔)。单用这个业务计算服务器的利用率会发现，服务器干正经事的时间和端口（资源）被挂着无法被使用的时间的比例是 1：几百，服务器资源严重浪费

怎么解决timewait过多的问题？

答：先可以设置打开系统的TIMEWAIT重用和快速回收，如果还是没有解决，采取负载均衡来抗这些高并发的短请求。持续十万并发的短连接请求，两台机器，每台5万个，应该够用了吧。一般的业务量以及国内大部分网站其实并不需要关注这个问题，一句话，达不到时才需要关注这个问题的访问量。

5、流量控制

`由于发一个包确认一个包后，再发送第二个包的模式效率太低，想一次发多个包确认多个包，就需要通信双方协商发送窗和接收窗，`

接收窗大小由接收端自身决定，发送窗口有左右两个边，左边代表被确认的序号，右边代表已发送序号。窗口的大小取决于下面两个数中的较小值：接收窗口（rwnd）和拥塞窗口（cwnd)，拥塞窗口由拥塞控制来传回，若接收窗口大，且没有拥塞，则会加大滑动窗口。。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。

6、拥塞控制

`防止网络中数据包过多，造成网络资源过载`

* 慢开始  由于一开始不清楚网络的承载能力，较好的办法是先试探一下，即由小到大逐渐的增大拥塞窗口的数值。每成功往返一次，就把窗口加倍。cwnd=1-->2-->4-->8-->16，默认慢开始门限是16，达到16后cwnd每次+1；

* 拥塞避免 默认慢开始门限是16，达到16后cwnd每次+1；让拥塞窗口的增大变慢一点，每成功往返一次，只把窗口加一而不是加倍。

* 快重传  网络出现了拥塞时，(如果发送方设置的超时计时器时限已到但还没有收到确认)， 这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。       快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。

* 快恢复  发送方认为此时网络没有拥塞，那么就会把窗口的值，直接设置为之前窗口减半时候的情况，然后执行拥塞避免，逐渐加一。

7、TCP如何提供可靠数据传输的？

确认和重传：确认到达，超时重传

数据校验

合理分片和排序：确保数据是按顺序到

流量控制   滑动窗口协议（窗口滑动+窗口大小调整）

拥塞控制

8、TCP soctet交互流程？

服务器：

创建socket -> int socket(int domain, int type, int protocol);

* domain：协议域，决定了socket的地址类型，IPv4为AF_INET。

* type：指定socket类型，SOCK_STREAM为TCP连接。

* protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。

绑定socket和端口号 -> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

* sockfd：socket返回的套接字描述符，类似于文件描述符fd。

* addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。

    // IPv4的sockaddr地址结构
    struct sockaddr_in {
        sa_family_t sin_family;    // 协议类型，AF_INET
        in_port_t sin_port;    // 端口号
        struct in_addr sin_addr;    // IP地址
    };
    struct in_addr {
        uint32_t s_addr;
    }
* addrlen：地址长度。
监听端口号 -> int listen(int sockfd, int backlog);

* sockfd：要监听的sock描述字。

* backlog：socket可以排队的最大连接数。

接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

* sockfd：服务器socket描述字。

* addr：指向地址结构指针。

*  addrlen：协议地址长度。

注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。

从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count);

* fd：连接描述字。

* buf：缓冲区buf。

* count：缓冲区长度。

注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。

关闭socket -> int close(int fd);

* fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。

注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。

客户机：

创建socket -> int socket(int domain, int type, int protocol);

连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);

* sockfd客户端的sock描述字。

* addr：服务器的地址。
 
* addrlen：socket地址长度。

向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);

* fd、buf、count：同read中意义。

* 大于0表示写了部分或全部数据，小于0表示出错。

关闭oscket -> int close(int fd);

* fd：同服务器端fd。

9、udp

udp省去了tcp的connect和accept环节，客户端绑定端口和ip地址，服务器端recvfrom会保存客户端的sock，保存到client中，相当于TCP中accept+recv

服务器：
```cpp
int fd=socker(af_inet,sock_dgram,0);
bind();
struct sockaddr_in client; 
int cli_len=siezeof(client)
recvfrom(fd,buf,sizeof(buf),0,(struct sockaddr *)&client,&cli_len);//client是传出参数，会保存客户端的ip+端口，相当于TCP中accept+recv
sendto(fd,buf,strlen(buf)+1,0,(struct sockaddr *)&client,siezeof(client));
close(fd);
```

10、udp的广播机制

udp的广播机制：
  1、服务器端只发数据，绑定广播地址xxx.xxx.123.255，发送到固定端口9898
  2、所以客户端要绑定到端口9898

服务器：
---
创建套接字

fd绑定服务器ip地址和端口
```cpp
struct sockaddr_in serv;
serv.sin_family=af_inet;
clientsin_.port=htons(9898);//服务器端口号
ser.sin_addr.s_addr=hton1(INADDR_ANY);//服务器IP地址
bind(fd,(struct sockaddr_in*)&serv,sizeof(serv));
```

发送数据

sendto(fd,buf,len,0);

设置广播权限
```cpp
int flag= -1;
setsockopt(fd,SOL_SOCKET ,SO_BROADCAST,&flag,sizeof(flag));
```
客户端:
---
创建套接字

初始化化客户端ip和端口信息
```cpp
struct sockaddr_in client;
client.sin_family=af_inet;
client.port=htons(9898);//客户端端口号=服务器端口号
inte_pton(af_inet,"xxx.xxx.123.255",&client.sin_addr.s_addr);//通过这个255就可以广播到123网段的所有客户端
```
显示地绑定ip和端口

bind();

接受数据<------serve

recvfrom();

适用范围: 只适用于局域网

11、UDP的组播

使用范围：局域网、Internet

结构体
```cpp
struct ip_mreqn
                      {
struct in_addr imr_multiaddr;  //组播组的IP地址
struct in_addr imr_interface;   //本地某一网络设备接口的IP地址
int imr_ifindex;        //网卡编号
}；
struct in_addr
{
int_addr_t  s_addr;
};
```
服务器
---
```cpp
创建套接字
fd绑定服务器ip地址和端口
struct sockaddr_in serv;
serv.sin_family=af_inet;
clientsin_.port=htons(9898);
ser.sin_addr.s_addr=hton1(INADDR_ANY);
bind(fd,(struct sockaddr_in*)&serv,sizeof(serv));
初始化化客户端ip和端口信息
struct sockaddr_in client;
client.sin_family=af_inet;
client.port=htons(9898);
inte_pton(af_inet,"239.0.0.10",&client.sin_addr.s_addr);//通过这个255就可以组播
发送数据
sendto(fd,buf,len,0);
设置组播权限（开启组播）
struct ip_mreqn flag;
inet_pton(AF_INET,"239.0.0.10",&flag.imr_multiaddr.s_addr);
inet_pton(AF_INET,"0.0.0.0",&flag.imr_address.s_addr);
flag.imr_ifindex=if_nametoindex("ens33");//网卡=====》mac地址
setsockopt(fd,IPPROTO_IP,IP_MULTICAST_IF,&flag,sizeof(flag));
客户端
设置客户端组播权限（加入）
struct ip_mreqn flag;
inet_pton(AF_INET,"239.0.0.10",&flag.imr_multiaddr.s_addr);
inet_pton(AF_INET,"0.0.0.0",&flag.imr_address.s_addr);
flag.imr_ifindex= if_nametoindex("ens33");//网卡=====》mac地址
setsockopt(fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&flag,sizeof(flag));
```

12、tcp和udp的比较

tcp：
* TCP面向连接（如打电话要先拨号建立连接）
* TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;
* TCP适用于对数据安全性要求高的时候，如登陆数据的传输，账户的账号密码，或者文件传输，可靠安全；以及常用的http协议都是在tcp基础上的

udp:
* UDP是无连接的，UDP是面向报文的
* UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
* UDP适用于对数据安全性无特殊要求，但对实时性要求较

应用层 HTTP
---
1、HTTP协议工作在应用层，端口号是80。HTTP协议被用于网络中两台计算机间的通信，相比于TCP/IP这些底层协议，HTTP协议更像是高层标记型语言，浏览器根据从服务器得到的HTTP响应体中分别得到报文头，响应头和信息体（HTML正文等），之后将HTML文件解析并呈现在浏览器上。同样，我们在浏览器地址栏输入网址之后，浏览器相当于用户代理帮助我们组织好报文头，请求头和信息体（可选），之后通过网络发送到服务器，服务器根据请求的内容准备数据。

从网络分层模型来看，HTTP工作在应用层，其在传输层由TCP协议为其提供服务。所以可以猜到，HTTP请求前，客户机和服务器之间一定已经通过三次握手建立起连接，其中套接字中服务器一侧的端口号为HTTP周知端口80。在请求和传输数据时也是有讲究的，通常一个页面上不只有文本数据，有时会内嵌很多图片，这时候有两种选择可以考虑。一种是对每一个文件都建立一个TCP连接，传送完数据后立马断开，通过多次这样的操作获取引用的所有数据，但是这样一个页面的打开需要建立多次连接，效率会低很多。另一种是对于有多个资源的页面，传送完一个数据后不立即断开连接，在同一次连接下多次传输数据直至传完，但这种情况有可能会长时间占用服务器资源，降低吞吐率。上述两种模式分别是HTTP 1.0和HTTP 1.1版本的默认方式，具体是什么含义会在后面详细解释。

2、HTTP协议结构
`请求报文`
![示意图](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1560671951(1).png)

报文头（只有一行）method uri version

* method

HTTP的请求方法，一共有9中，但GET和POST占了99%以上的使用频次。GET表示向特定资源发起请求，当然也能提交部分数据，不过提交的数据以明文方式出现在URL中。POST通常用于向指定资源提交数据进行处理，提交的数据被包含在请求体中，相对而言比较安全些。

* uri

用来指代请求的文件，≠URL。

* version

HTTP协议的版本，该字段有HTTP/1.0和HTTP/1.1两种。

请求头（多行） 在HTTP/1.1中，请求头除了Host都是可选的。包含的头五花八门，这里只介绍部分。

Host：指定请求资源的主机和端口号。端口号默认80。

Connection：值为keep-alive和close。keep-alive使客户端到服务器的连接持续有效，不需要每次重连，此功能为HTTP/1.1预设功能。

Accept：浏览器可接收的MIME类型。假设为text/html表示接收服务器回发的数据类型为text/html，如果服务器无法返回这种类型，返回406错误。

Cache-control：缓存控制，Public内容可以被任何缓存所缓存，Private内容只能被缓存到私有缓存，non-cache指所有内容都不会被缓存。

Cookie：将存储在本地的Cookie值发送给服务器，实现无状态的HTTP协议的会话跟踪。

Content-Length：请求消息正文长度。

另有User-Agent、Accept-Encoding、Accept-Language、Accept-Charset、Content-Type等请求头这里不一一罗列。由此可见，请求报文是告知服务器请求的内容，而请求头是为了提供服务器一些关于客户机浏览器的基本信息，包括编码、是否缓存等。

空行（一行）

可选消息体（多行）

`响应报文`
![示意图](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1560672300(1).png)
响应报文是服务器对请求资源的响应，通过上面提到的方式同样可以看到，同样地，数据也是以"\r\n"来分割。

报文头（一行）

结构：version status_code status_message

version

描述所遵循的HTTP版本。

status_code

状态码，指明对请求处理的状态，常见的如下。

200：成功。

301：内容已经移动。

400：请求不能被服务器理解。

403：无权访问该文件。

404：不能找到请求文件。

500：服务器内部错误。

501：服务器不支持请求的方法。

505：服务器不支持请求的版本。

status_message

显示和状态码等价英文描述。

响应头（多行）

这里只罗列部分。

Date：表示信息发送的时间。

Server：Web服务器用来处理请求的软件信息。

Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。

Content-Length：服务器告知浏览器自己响应的对象长度。

Content-Type：告知浏览器响应对象类型。

`3、http1.0 1.1 2.0区别`
---
* HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
* HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401；客户端如果接受到100，才开始把请求body发送到服务器，而服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。
* HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。同时慢启动时间的减少,使拥塞和丢包恢复速度更快。
* HTTP2.0相比1.x版本最大的优势是，关键之一就是在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流，对顺时并发的支持可以充分利用带宽的作用。性能提升包括带宽和延时，1.x版本只是尽量减小延时，2.0版本致力于增大带宽的利用率。

4、http长连接和短连接
---
假设有一个网页，里面包含好多图片，还包含好多【外部的】CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对【每一个】外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开）
相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。
在 HTTP 1.0 版本，【默认】使用的是“短连接”； 1995年的HTTP 1.1 默认长链接

5、会话机制
---
HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。

- Cookie

    Cookie是客户端保持状态的方法。

    Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。

    除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。

- Session

    Session是服务器保持状态的方法。

    首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。

     当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。

6、加密算法
---
1、非对称加密 :(RSA,MD5，SHA1，SHA256)：

公钥加密---->私钥解密，或者私钥加密---->公钥解密，但是不能私钥加密---->私钥解密！！

2、MD5加密


MD5算法：MD5算法就像一个函数，任意一个二进制串都可以作为自变量进入这个“函数”，然后会出来一个固定为128位的二进制串。

MD5为什么不可逆？答：hash函数的原理，是把很大长度的数据，映射到固定长度的数据上去

MD5步骤：
   
   （1）一个字符为8bit，一个字符串的二进制用小端形式存储在计算机中，人为地先补一个1，再补0，补够448位；然后再在后面写上   原始信息长度 mod 2^64，得到的结果表示为64位二进制，
   
   “hello”的二进制用小端形式存储：
   
   ```cpp
   01101000 01100101 01101100 01101100 01101111 [存储]
   ```
   后面续上原始信息长度   40 mod 2^64=40，结果表示为64位二进制:
   ```cpp
   00101000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [存储]
   ```
   二进制补位完成
   ```cpp
   01101000 01100101 01101100 01101100 01101111 1 (407个0)00101000 00000000 0000000000000000 00000000 00000000 00000000 00000000 [存储]
   ```
   (2)然后对这个512个位平均分成16组，每组32个位：
   ```c
   第1组：01101000 01100101 01101100 01101100 
     第2组：01101111 10000000 00000000 00000000 
     … 
     第32组：00000000 00000000 00000000 00000000
   ```
   (3)然后使用四个常数进行运算：A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476。 进过一系列运算后，A,B,C,D的值都获得了更新 
把这四个数A -> B -> C -> D按照从低内存到高内存排列起来，共128位，这就是MD5算法的输出。

7、RSA加密
---

8、数字签名和数字证书的关系
---
数字签名（Digital Signature）：
 数据在浏览器和服务器之间传输时，有可能在传输过程中被冒充的盗贼把内容替换了，那么如何保证数据 是真实服务器发送的而不被调包，不被篡改，就要用到数字签名。
 在计算机中的数字签名怎么回事呢？
数字签名就是用于验证传输的内容是不是真实服务器发送的数 据，发送的数据有没有被篡改过，它就干这两件事，是非对称加密的一种应用场景。不过他是反过来用私 钥来加密，通过与之配对的公钥来解密。 
第一步：服务端把报文经过Hash处理后生成摘要信息Digest，摘要信息使用私钥加密，这就是签名，服务器把签名连同报文一起发送给客户端。 
第二步：客户端接收到数据后，把签名提取出来用公钥解密，如果能正常的解密出来Digest2，那么 就能确认是对方发的。（黑客要修改信息的话，由于手上没有秘钥，所以没法正常进行步骤一） 
第三步：客户端把报文Text提取出来做同样的Hash处理，得到的摘要信息Digest1，再与之前解密出来的 Digist2对比，如果两者相等，就表示内容没有被篡改，否则内容就是被人改过了。因为只要文本内容哪怕 有任何一点点改动都会Hash出一个完全不一样的摘要信息出来。

数字证书：
n个网站服务器都在CA这里备案，然后由CA将证书发送给客户端，；证书里面包含了真实服务器的公钥和网站的一些其他信息，数字证书机构用自己的私钥加密后发给浏览 器，浏览器使用数字证书机构的公钥解密后得到真实服务器的公钥；

非对称加密：服务器给客户一把钥匙（公钥），传播一把锁（私钥解密后的密文），用这个钥匙就能打开这个锁；
数字签名：给这个锁加个指纹，说明是我的锁
数字证书：防止有人给了一套假的钥匙和锁，虽然钥匙还能打开锁；

9、DDOS攻击
---
利用服务器建立tcp连接的三次握手，客户端假造一个IP地址，服务器确认后会回复，这时客户端并不回应第三次握手，而服务端的主机会为这些源主机建立大量的连接队列，由于没有收到ack就一直维护这些连接队列，造成资源的大量消耗而不能向正常的请求提供服务。这样就造成服务器的资源浪费；如果黑客发动大量的SYN-ACK攻击，就会占用服务器大量的带宽，造成服务器拒绝服务。

10 HTTPS的工作原理
---
我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。

　客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤：
 
 （1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。　　
 
 （2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。　　
 
 （3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。　　
 
 （4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。　
 
 （5）Web服务器利用自己的私钥解密出会话密钥。　　
 
 （6）Web服务器利用会话密钥加密与客户端之间的通信。
 
 11  http重定向怎么实现？
---
答：服务器无法处理发过来的请求，就会返回给浏览器一个lacation响应（包含一个新的url），让服务器连新的url。

状态码：301：永久性转移      302：暂时性转移

重定向过程：客户浏览器发送http请求——》web服务器接受后发送302状态码响应及对应新的location给客户浏览器——》客户浏览器发现是302响应，则自动再发送一个新的http请求，请求url是新的location地址——》服务器根据此请求寻找资源并发送给客户。（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）

请求转发过程：客户浏览器发送http请求——》web服务器接受此请求——》浏览器调用内部的一个方法，在容器内部完成请求处理和转发动作——》将目标资源发送给客户；（用户看不到跳转）




