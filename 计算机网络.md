计算机网络
===
`重点是ip、tcp、http`

网络层（IP）
--
传输层（TCP/UDP）
---
 1、描述TCP头部？

* 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。

* 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1；第一次收到1024，确认号为1025。

* 首部长（4bit）：标识首部长度0~15，一个长度代表4字节，最大为15，即60字节。

* 标志位（6bit）：

    URG：标志紧急指针是否有效。

    ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。

    PSH：提示接收端立即从缓冲读走数据。

    RST：表示要求对方重新建立连接（复位报文段）。

    SYN：表示请求建立一个连接（连接报文段）。

    FIN：表示关闭连接（断开报文段）。

* 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。

* 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。

 2、三次握手和四次挥手过程？
![示意图](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clipboard.png)
三次握手：客户端发起连接请求，SYN=1表示连接请求，随机的序列号SEQ_NUM=s；服务器收到后向客户端回复，发送确认包ACK=1,ACK_NUM=S+1,随机的序列号SEQ_NUM=q；客户端第三次回复ACK=1，ACK_NUM=q+1；

四次挥手：客户机发含FIN位，SEQ = Q的包到服务器。第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器，此处有等待。第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机，有等待。第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -> CLOSED）

3、FIN_WAIT_2，CLOSE_WAIT状态？

服务器在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否可以断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，要先等待服务器的数据包发送，在发送FIN包之前服务器均为CLOSE_WAIT，客户端为FIN_WAIT_2。等数据发送完毕，服务器发送第三次挥手，客户端收到FIN后，状态FIN_WAIT_2结束。

4、主动结束连接的一方为什么要等待2MSL？

A<-------B(B发FIN到A，第三次握手)
A------->B（A发ack到B，第四次握手）
为了防止第四次挥手没有正常达到对方，假如ACK没有到达B，B会为FIN这个消息超时重传,那如果A等待时间足够,又收到FIN消息,说明ACK没有到达B，于是再发送ACK，知道在足够的时间内没有收到FIN，说明ACK成功到达。

5、流量控制

`由于发一个包确认一个包后，再发送第二个包的模式效率太低，想一次发多个包确认多个包，就需要通信双方协商发送窗和接收窗，`

接收窗大小由接收端自身决定，发送窗口有左右两个边，左边代表被确认的序号，右边代表已发送序号。窗口的大小取决于下面两个数中的较小值：接收窗口（rwnd）和拥塞窗口（cwnd)，拥塞窗口由拥塞控制来传回，若接收窗口大，且没有拥塞，则会加大滑动窗口。。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。

6、拥塞控制

`防止网络中数据包过多，造成网络资源过载`

* 慢开始  由于一开始不清楚网络的承载能力，较好的办法是先试探一下，即由小到大逐渐的增大拥塞窗口的数值。每成功往返一次，就把窗口加倍。cwnd=1-->2-->4-->8-->16，默认慢开始门限是16，达到16后cwnd每次+1；
* 拥塞避免 默认慢开始门限是16，达到16后cwnd每次+1；让拥塞窗口的增大变慢一点，每成功往返一次，只把窗口加一而不是加倍。
* 快重传  网络出现了拥塞时，(如果发送方设置的超时计时器时限已到但还没有收到确认)， 这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。       快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。
* 快恢复  发送方认为此时网络没有拥塞，那么就会把窗口的值，直接设置为之前窗口减半时候的情况，然后执行拥塞避免，逐渐加一。

7、TCP如何提供可靠数据传输的？

确认和重传：确认到达，超时重传

数据校验

合理分片和排序：确保数据是按顺序到

流量控制   滑动窗口协议（窗口滑动+窗口大小调整）

拥塞控制

8、TCP soctet交互流程？

服务器：

创建socket -> int socket(int domain, int type, int protocol);

domain：协议域，决定了socket的地址类型，IPv4为AF_INET。

type：指定socket类型，SOCK_STREAM为TCP连接。

protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。

绑定socket和端口号 -> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

sockfd：socket返回的套接字描述符，类似于文件描述符fd。

addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。

    // IPv4的sockaddr地址结构
    struct sockaddr_in {
        sa_family_t sin_family;    // 协议类型，AF_INET
        in_port_t sin_port;    // 端口号
        struct in_addr sin_addr;    // IP地址
    };
    struct in_addr {
        uint32_t s_addr;
    }
addrlen：地址长度。
监听端口号 -> int listen(int sockfd, int backlog);

sockfd：要监听的sock描述字。

backlog：socket可以排队的最大连接数。

接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

sockfd：服务器socket描述字。

addr：指向地址结构指针。

addrlen：协议地址长度。

注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。

从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count);

fd：连接描述字。

buf：缓冲区buf。

count：缓冲区长度。

注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。

关闭socket -> int close(int fd);

fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。

注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。

客户机：

创建socket -> int socket(int domain, int type, int protocol);

连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);

sockfd客户端的sock描述字。

addr：服务器的地址。

addrlen：socket地址长度。

向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);

fd、buf、count：同read中意义。

大于0表示写了部分或全部数据，小于0表示出错。

关闭oscket -> int close(int fd);

fd：同服务器端fd。
