计算机网络
===
`重点是ip、tcp、http`

网络层（IP）
--
传输层（TCP/UDP）
---
 1、描述TCP头部？

* 序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -> B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。

* 确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1；第一次收到1024，确认号为1025。

* 首部长（4bit）：标识首部长度0~15，一个长度代表4字节，最大为15，即60字节。

* 标志位（6bit）：

    URG：标志紧急指针是否有效。

    ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。

    PSH：提示接收端立即从缓冲读走数据。

    RST：表示要求对方重新建立连接（复位报文段）。

    SYN：表示请求建立一个连接（连接报文段）。

    FIN：表示关闭连接（断开报文段）。

* 窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。

* 校验和（16bit）：接收端用CRC检验整个报文段有无损坏。

 2、三次握手和四次挥手过程？
![示意图](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/clipboard.png)
三次握手：客户端发起连接请求，SYN=1表示连接请求，随机的序列号SEQ_NUM=s；服务器收到后向客户端回复，发送确认包ACK=1,ACK_NUM=S+1,随机的序列号SEQ_NUM=q；客户端第三次回复ACK=1，ACK_NUM=q+1；

四次挥手：客户机发含FIN位，SEQ = Q的包到服务器。第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器，此处有等待。第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机，有等待。第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -> CLOSED）

3、FIN_WAIT_2，CLOSE_WAIT状态？

服务器在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否可以断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，要先等待服务器的数据包发送，在发送FIN包之前服务器均为CLOSE_WAIT，客户端为FIN_WAIT_2。等数据发送完毕，服务器发送第三次挥手，客户端收到FIN后，状态FIN_WAIT_2结束。

4、主动结束连接的一方为什么要等待2MSL？

A<-------B(B发FIN到A，第三次握手)
A------->B（A发ack到B，第四次握手）
为了防止第四次挥手没有正常达到对方，假如ACK没有到达B，B会为FIN这个消息超时重传,那如果A等待时间足够,又收到FIN消息,说明ACK没有到达B，于是再发送ACK，知道在足够的时间内没有收到FIN，说明ACK成功到达。

5、流量控制

`由于发一个包确认一个包后，再发送第二个包的模式效率太低，想一次发多个包确认多个包，就需要通信双方协商发送窗和接收窗，`

接收窗大小由接收端自身决定，发送窗口有左右两个边，左边代表被确认的序号，右边代表已发送序号。窗口的大小取决于下面两个数中的较小值：接收窗口（rwnd）和拥塞窗口（cwnd)，拥塞窗口由拥塞控制来传回，若接收窗口大，且没有拥塞，则会加大滑动窗口。。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。

6、拥塞控制

`防止网络中数据包过多，造成网络资源过载`

* 慢开始  由于一开始不清楚网络的承载能力，较好的办法是先试探一下，即由小到大逐渐的增大拥塞窗口的数值。每成功往返一次，就把窗口加倍。cwnd=1-->2-->4-->8-->16，默认慢开始门限是16，达到16后cwnd每次+1；
* 拥塞避免 默认慢开始门限是16，达到16后cwnd每次+1；让拥塞窗口的增大变慢一点，每成功往返一次，只把窗口加一而不是加倍。
* 快重传  网络出现了拥塞时，(如果发送方设置的超时计时器时限已到但还没有收到确认)， 这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。       快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时才进行捎带确认。
* 快恢复  发送方认为此时网络没有拥塞，那么就会把窗口的值，直接设置为之前窗口减半时候的情况，然后执行拥塞避免，逐渐加一。

7、TCP如何提供可靠数据传输的？

确认和重传：确认到达，超时重传

数据校验

合理分片和排序：确保数据是按顺序到

流量控制   滑动窗口协议（窗口滑动+窗口大小调整）

拥塞控制

8、TCP soctet交互流程？

服务器：

创建socket -> int socket(int domain, int type, int protocol);

* domain：协议域，决定了socket的地址类型，IPv4为AF_INET。

* type：指定socket类型，SOCK_STREAM为TCP连接。

* protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。

绑定socket和端口号 -> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

* sockfd：socket返回的套接字描述符，类似于文件描述符fd。

* addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。

    // IPv4的sockaddr地址结构
    struct sockaddr_in {
        sa_family_t sin_family;    // 协议类型，AF_INET
        in_port_t sin_port;    // 端口号
        struct in_addr sin_addr;    // IP地址
    };
    struct in_addr {
        uint32_t s_addr;
    }
* addrlen：地址长度。
监听端口号 -> int listen(int sockfd, int backlog);

* sockfd：要监听的sock描述字。

* backlog：socket可以排队的最大连接数。

接收用户请求 -> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

* sockfd：服务器socket描述字。

* addr：指向地址结构指针。

*  addrlen：协议地址长度。

注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。

从socket中读取字符 -> ssize_t read(int fd, void *buf, size_t count);

* fd：连接描述字。

* buf：缓冲区buf。

* count：缓冲区长度。

注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。

关闭socket -> int close(int fd);

* fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。

注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。

客户机：

创建socket -> int socket(int domain, int type, int protocol);

连接指定计算机 -> int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);

* sockfd客户端的sock描述字。

* addr：服务器的地址。
 
* addrlen：socket地址长度。

向socket写入信息 -> ssize_t write(int fd, const void *buf, size_t count);

* fd、buf、count：同read中意义。

* 大于0表示写了部分或全部数据，小于0表示出错。

关闭oscket -> int close(int fd);

* fd：同服务器端fd。

9、udp

udp省去了tcp的connect和accept环节，客户端绑定端口和ip地址，服务器端recvfrom会保存客户端的sock，保存到client中，相当于TCP中accept+recv

服务器：
```cpp
int fd=socker(af_inet,sock_dgram,0);
bind();
struct sockaddr_in client; 
int cli_len=siezeof(client)
recvfrom(fd,buf,sizeof(buf),0,(struct sockaddr *)&client,&cli_len);//client是传出参数，会保存客户端的ip+端口，相当于TCP中accept+recv
sendto(fd,buf,strlen(buf)+1,0,(struct sockaddr *)&client,siezeof(client));
close(fd);
```

10、udp的广播机制

udp的广播机制：
  1、服务器端只发数据，绑定广播地址xxx.xxx.123.255，发送到固定端口9898
  2、所以客户端要绑定到端口9898

服务器：
---
创建套接字

fd绑定服务器ip地址和端口
```cpp
struct sockaddr_in serv;
serv.sin_family=af_inet;
clientsin_.port=htons(9898);//服务器端口号
ser.sin_addr.s_addr=hton1(INADDR_ANY);//服务器IP地址
bind(fd,(struct sockaddr_in*)&serv,sizeof(serv));
```

发送数据

sendto(fd,buf,len,0);

设置广播权限
```cpp
int flag= -1;
setsockopt(fd,SOL_SOCKET ,SO_BROADCAST,&flag,sizeof(flag));
```
客户端:
---
创建套接字

初始化化客户端ip和端口信息
```cpp
struct sockaddr_in client;
client.sin_family=af_inet;
client.port=htons(9898);//客户端端口号=服务器端口号
inte_pton(af_inet,"xxx.xxx.123.255",&client.sin_addr.s_addr);//通过这个255就可以广播到123网段的所有客户端
```
显示地绑定ip和端口

bind();

接受数据<------serve

recvfrom();

适用范围: 只适用于局域网

11、UDP的组播

使用范围：局域网、Internet

结构体
```cpp
struct ip_mreqn
                      {
struct in_addr imr_multiaddr;  //组播组的IP地址
struct in_addr imr_interface;   //本地某一网络设备接口的IP地址
int imr_ifindex;        //网卡编号
}；
struct in_addr
{
int_addr_t  s_addr;
};
```
服务器
---
```cpp
创建套接字
fd绑定服务器ip地址和端口
struct sockaddr_in serv;
serv.sin_family=af_inet;
clientsin_.port=htons(9898);
ser.sin_addr.s_addr=hton1(INADDR_ANY);
bind(fd,(struct sockaddr_in*)&serv,sizeof(serv));
初始化化客户端ip和端口信息
struct sockaddr_in client;
client.sin_family=af_inet;
client.port=htons(9898);
inte_pton(af_inet,"239.0.0.10",&client.sin_addr.s_addr);//通过这个255就可以组播
发送数据
sendto(fd,buf,len,0);
设置组播权限（开启组播）
struct ip_mreqn flag;
inet_pton(AF_INET,"239.0.0.10",&flag.imr_multiaddr.s_addr);
inet_pton(AF_INET,"0.0.0.0",&flag.imr_address.s_addr);
flag.imr_ifindex=if_nametoindex("ens33");//网卡=====》mac地址
setsockopt(fd,IPPROTO_IP,IP_MULTICAST_IF,&flag,sizeof(flag));
客户端
设置客户端组播权限（加入）
struct ip_mreqn flag;
inet_pton(AF_INET,"239.0.0.10",&flag.imr_multiaddr.s_addr);
inet_pton(AF_INET,"0.0.0.0",&flag.imr_address.s_addr);
flag.imr_ifindex= if_nametoindex("ens33");//网卡=====》mac地址
setsockopt(fd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&flag,sizeof(flag));
```

12、tcp和udp的比较

tcp：
* TCP面向连接（如打电话要先拨号建立连接）
* TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;
* TCP适用于对数据安全性要求高的时候，如登陆数据的传输，账户的账号密码，或者文件传输，可靠安全；以及常用的http协议都是在tcp基础上的

udp:
* UDP是无连接的，UDP是面向报文的
* UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
* UDP适用于对数据安全性无特殊要求，但对实时性要求较

应用层 HTTP
---
1、HTTP协议工作在应用层，端口号是80。HTTP协议被用于网络中两台计算机间的通信，相比于TCP/IP这些底层协议，HTTP协议更像是高层标记型语言，浏览器根据从服务器得到的HTTP响应体中分别得到报文头，响应头和信息体（HTML正文等），之后将HTML文件解析并呈现在浏览器上。同样，我们在浏览器地址栏输入网址之后，浏览器相当于用户代理帮助我们组织好报文头，请求头和信息体（可选），之后通过网络发送到服务器，服务器根据请求的内容准备数据。

从网络分层模型来看，HTTP工作在应用层，其在传输层由TCP协议为其提供服务。所以可以猜到，HTTP请求前，客户机和服务器之间一定已经通过三次握手建立起连接，其中套接字中服务器一侧的端口号为HTTP周知端口80。在请求和传输数据时也是有讲究的，通常一个页面上不只有文本数据，有时会内嵌很多图片，这时候有两种选择可以考虑。一种是对每一个文件都建立一个TCP连接，传送完数据后立马断开，通过多次这样的操作获取引用的所有数据，但是这样一个页面的打开需要建立多次连接，效率会低很多。另一种是对于有多个资源的页面，传送完一个数据后不立即断开连接，在同一次连接下多次传输数据直至传完，但这种情况有可能会长时间占用服务器资源，降低吞吐率。上述两种模式分别是HTTP 1.0和HTTP 1.1版本的默认方式，具体是什么含义会在后面详细解释。

2、HTTP协议结构
`请求报文`
![示意图](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1560671951(1).png)

报文头（只有一行）method uri version

* method

HTTP的请求方法，一共有9中，但GET和POST占了99%以上的使用频次。GET表示向特定资源发起请求，当然也能提交部分数据，不过提交的数据以明文方式出现在URL中。POST通常用于向指定资源提交数据进行处理，提交的数据被包含在请求体中，相对而言比较安全些。

* uri

用来指代请求的文件，≠URL。

* version

HTTP协议的版本，该字段有HTTP/1.0和HTTP/1.1两种。

请求头（多行） 在HTTP/1.1中，请求头除了Host都是可选的。包含的头五花八门，这里只介绍部分。

Host：指定请求资源的主机和端口号。端口号默认80。

Connection：值为keep-alive和close。keep-alive使客户端到服务器的连接持续有效，不需要每次重连，此功能为HTTP/1.1预设功能。

Accept：浏览器可接收的MIME类型。假设为text/html表示接收服务器回发的数据类型为text/html，如果服务器无法返回这种类型，返回406错误。

Cache-control：缓存控制，Public内容可以被任何缓存所缓存，Private内容只能被缓存到私有缓存，non-cache指所有内容都不会被缓存。

Cookie：将存储在本地的Cookie值发送给服务器，实现无状态的HTTP协议的会话跟踪。

Content-Length：请求消息正文长度。

另有User-Agent、Accept-Encoding、Accept-Language、Accept-Charset、Content-Type等请求头这里不一一罗列。由此可见，请求报文是告知服务器请求的内容，而请求头是为了提供服务器一些关于客户机浏览器的基本信息，包括编码、是否缓存等。

空行（一行）

可选消息体（多行）

响应报文
---
[示意图]()
响应报文是服务器对请求资源的响应，通过上面提到的方式同样可以看到，同样地，数据也是以"\r\n"来分割。

报文头（一行）

结构：version status_code status_message

version

描述所遵循的HTTP版本。

status_code

状态码，指明对请求处理的状态，常见的如下。

200：成功。

301：内容已经移动。

400：请求不能被服务器理解。

403：无权访问该文件。

404：不能找到请求文件。

500：服务器内部错误。

501：服务器不支持请求的方法。

505：服务器不支持请求的版本。

status_message

显示和状态码等价英文描述。

响应头（多行）

这里只罗列部分。

Date：表示信息发送的时间。

Server：Web服务器用来处理请求的软件信息。

Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。

Content-Length：服务器告知浏览器自己响应的对象长度。

Content-Type：告知浏览器响应对象类型。
