
1.C 和 C++ 区别
----
C++是在C语言的基础上开发的一种面向对象编程语言，C++支持多种编程范式 －－面向对象编程、泛型编程和过程化编程。常用于系统开发，引擎开发等应用领域，支持类：类、封装、重载等特性!

c++在c的基础上增添类，C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。

2.const 有什么用途
----
 主要有三点：

1：定义只读变量，即常量（类成员变量和普通变量） 
 
2：修饰函数的参数和函数的返回值

3： const修饰类成员函数，承诺在本函数内部不会修改类内的数据成员，不会调用其它非 const 成员函数。

注意：类中定义const成员变量，那么这个变量只能在初始化列表中进行初始化。

C++11：const string &，常引用做形参，既可以接左值（有名），又可以接右值（匿名）

请说出const与#define 相比，有何优点？
----
一：区别

（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。

（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。

（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份，const可节省空间，避免不必要的内存分配，提高效率。

（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

const int a;===int const a;  定义常量类型a

const int *a;===Int const *a; 指针指向的地方不可修改

int *const a; const指针

写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个？
---

答案：#define MIN(A,B) ((A) <= (B) ? (A) : (B)) 

要点：

A.参数用括号括起来;

B.考察能否合理运用条件运算符;

补1 设计模式懂嘛，简单举个例子？
---
设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。
比如单例模式，保证一个类仅有一个实例，并提供一个访问它的全局访问点。适用于：当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时；当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。
比如工厂模式，定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。适用于：当一个类不知道它所必须创建的对象的类的时候；当一个类希望由它的子类来指定它所创建的对象的时候；当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。

3.指针和引用的区别
---
    1：引用是变量的一个别名，内部实现是只读指针
    2：引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变，且指针可以改变所指的对象；
    3：引用不能为NULL，指针可以为NULL；引用必须被初始化，指针不必。
    4：“sizeof 引用" = 指向变量的大小 ， "sizeof 指针"= 指针本身的大小
    5：引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址
    6：引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址`
 

将“引用”作为函数参数有哪些特点？

（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。只不过传引用阅读性>指针。

（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，不需要分配内存它是直接对实参操作；如果传递的是对象，形参传值还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。

4.C++中有了malloc / free , 为什么还需要 new / delete   
---
  malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
a、对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。 由于malloc/free是库函数而不是运算符，不能做到自动执行构造析构。

b、对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。new可以创建复杂数据类型，而malloc只能给系统数据类型分配内存。
 
C、malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

delete与 delete []区别
---
delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。”delete与new配套，delete []与new []配套
```
MemTest *mTest1=new MemTest[10];
MemTest *mTest2=new MemTest;
Int *pInt1=new int [10];
Int *pInt2=new int;
delete[]pInt1; //-1-  
delete[]pInt2; //-2-  √，对于简单类型，delete和delete[]功能是相同的
delete[]mTest1;//-3-
delete[]mTest2;//-4-  报错
在-4-处报错。
```
这就说明：对于内建简单数据类型，delete和delete[]功能是相同的。对于自定义的复杂数据类型，delete和delete[]不能互用。delete[]删除一个数组，delete删除一个指针。简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。

5.复杂数据类型解释
---
`
1.void * ( * (*fp1)(int))[10];   fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。

2.float (*(* fp2)(int,int,int))(int);   fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。

3.int (* ( * fp3)())[10]();   fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。

int *p[10]  //数组p，数组内每个元素都是指向int类型的指针变量。

int (*p)[10]//数组指针,指向含10个int的数组

int (*s[10])(int) 函数指针数组s，每个指针指向一 int func(int param)的函数。

int *p(int) //函数

int (*p)(int)//函数指针`

6.编写类String 的构造函数，析构函数，拷贝构造函数和赋值函数
---
7.解释下封装、继承和多态？
---
答：一、封装：

封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。

封装的意义在于保护或者防止代码（数据）被我们无意中破坏。

二、继承：

继承主要实现重用代码，节省开发时间。
子类可以继承父类的一些东西。

三、多态

多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

继承的几种方式：
---
* public/protected/privated 继承的关系和区别？
* 多继承
* 虚继承

8.多态的实现场景
---
继承、基类函数加virtual关键字、函数重新、基类指针指向子类对象

9 子类析构时要调用父类的析构函数吗？
---
析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数。

10、多态，虚函数，纯虚函数
---
多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；
在程序编译时多态性体现在函数和运算符的重载上。

虚函数：在基类中冠以关键字 virtual 的成员函数。 它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。
纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义，作为接口而存在。纯虚函数不具备函数的功能，一般不能直接被调用。
从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。

抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，抽象类不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。

什么是虚函数？什么是纯虚函数？
---
虚函数声明如下： virtual ReturnType FunctionName(Parameter)；引入虚函数是为了动态绑定。
纯虚函数声明如下：virtual ReturnType FunctionName()= 0；引入纯虚函数是为了派生接口。
虚函数

定义一个函数为虚函数，不代表函数为不被实现的函数

定义他为虚函数是为了允许用基类的指针来调用子类的这个函数

C++中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数；在派生类中对基类定义的虚函数进行重写时，需要再派生类中声明该方法为虚方法。

当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，[即B b; A a = &b;] 父类指针根据赋给它的不同子类指针，动态的调用子类的该函数，而不是父类的函数（如果不使用virtual方法，请看后面），且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。
如果使用了virtual关键字，程序将根据引用或指针指向的对象类型来选择方法，否则使用引用类型或指针类型来选择方法。

2、 纯虚函数是否可以实例化

c++中包含纯虚函数的类是不允许被实例化的！！！进一步说，如果继承该类的类不重写这个纯虚函数的话，也是不允许被实例化的。即，包含纯虚函是的类派生出来的类都必须重写这个纯虚函数！

不能声明为虚函数的有哪些
---
1、静态成员函数； 2、类外的普通函数； 3、构造函数； 4、友元函数

虚函数是为了实现多态特性的。虚函数的调用只有在程序运行的时候才能知道到底调用的是哪个函数，其是有有如下几点需要注意：

（1） 类的构造函数不能是虚函数

构造函数是为了构造对象的，所以在调用构造函数时候必然知道是哪个对象调用了构造函数，所以构造函数不能为虚函数。

（2） 类的静态成员函数不能是虚函数

类的静态成员函数是该类共用的，与该类的对象无关，静态函数里没有this指针，所以不能为虚函数。

（3）内联函数

内联函数的目的是为了减少函数调用时间。它是把内联函数的函数体在编译器预处理的时候替换到函数调用处，这样代码运行到这里时候就不需要花时间去调用函数。inline是在编译器将函数类容替换到函数调用处，是静态编译的。而虚函数是动态调用的，在编译器并不知道需要调用的是父类还是子类的虚函数，所以不能够inline声明展开，所以编译器会忽略。

（4）友元函数

友元函数与该类无关，没有this指针，所以不能为虚函数。


11、重载（overload）和重写（overried） 重定义
---
重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同），返回值不是重载的标志。
--》同一个类中
重写：是指子类重新定义父类虚函数的方法。--》继承中

从实现原理上来说：

重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！

重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。

基类的析构函数不是虚函数，会带来什么问题？

【参考答案】用基类指针指向子类对象，当delete这个基类指针时，不会调子类的析构函数，造成派生类的析构函数用不上，会造成资源的泄漏。

12.单链表的逆置
---
13.全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？
---
【参考答案】

生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；
使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。 
操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

14.堆和栈的区别 
---
  一个由c/C++编译的程序占用的内存分为以下几个部分 
  
  1、栈区（stack）―   由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 
  
  2、堆区（heap） ―   一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。
  
   注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 
     
  3、全局区（静态区）（static），全局变量和静态变量的存储是放在一块的， 初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放 
  
  4、文字常量区  ―常量字符串就是放在这里的。 程序结束后由系统释放 
  
  5、程序代码区―存放函数体的二进制代码。
  
  6、栈大小比较有限，通常只有几kb，如果在死循环内不断申请内存的话，会造成栈溢出overflow。而堆是内存不连续区域，是用链表来存储地址的，堆有可能产生内存碎片，堆大小受限于计算机系统中有效虚拟内存。由此可见，堆获得空间比较灵活，也比较大。
  
15.不调用C/C++ 的字符串库函数，编写strcpy
---
   char * strcpy(char * strDest,const char * strSrc)
        {
                if ((strDest==NULL)||strSrc==NULL))                     
                   return NULL;    
                char * strDestCopy=strDest; 
                while ((*strDest++=*strSrc++)!='\0'); 
                *strDest = '\0';
                return strDestCopy;
        }


16、C语言中变量的存储类型有哪些
---
https://www.cnblogs.com/zhangruilin/p/5769842.html

C语言中的存储类型有auto，extern，register，static四种

* auto：自动变量，可以不写，默认情况下局部变量就是auto
* register：寄存器变量，把经常被调用的变量声明为寄存器变量，快速存储
* extern: 静态存储类别的变量，在另一个文件中，通过extern 全局变量名的声明
* static：静态存储类别的变量

静态存储类别的变量，从程序的开始处就存在，其生命期伴随整个程序，一直存在程序的执行过程。static变量仅仅在变量的作用范围内可见,而全局变量是在所有地方都可见的,这就是static变量与全局变量的区别，全局变量是不显示用static修饰的全局变量，但全局变量默认是静态的，作用域是整个工程。

17.关键字static的作用---->const（变为常量，防修改）static（限制区域）
---
类外：

1、修饰函数体内的变量， static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值。static的数据记忆性可以满足函数在不同调用期的通信。

2、修饰全局变量或者全局函数，相对于全局变量其可见范围被缩小，只能在本文件中可见，即隐藏作用。

类外：

 1.  在类内的 static 变量可以被模块内所有函数访问，但不能被模块外其他函数访问；变量属于整个类所拥有，可以满足同一个类的多个实例间的通信，对类的所有对象只有一份拷贝；类的静态成员变量在类实例化之前就已经存在了，并且分配了内存。函数的static变量在执行此函数时进行初始化。
 
2.  在类内的static 函数只能被这一模块内的其他函数调用，函数的使用范围仅在声明它的模块内， static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量

 隐藏作用详解：（static函数，static变量均可） 
 
当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。
```cpp
   //a.c
    char a = 'A';               // global variable
    void msg()
    {
      printf("Hello\n");
    }

  //main.c
   int main()
   {
     extern char a;       // extern variable must be declared before use
     printf("%c ", a);
     (void)msg();
     return 0;
   }
```
程序的运行结果是： A Hello

为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？

  前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。
  
  如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。 利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏
   
18、解释C++中静态函数和静态变量？
---
答：(1)类静态变量在编译时创建并初始化：在该类的任何对象建立之前就存在，不属于任何对象，而非静态类成员变量则是属于对象所有的。类静态数据成员只有一个拷贝，为所有此类的对象所共享。

(2)类静态成员变量属于整个类，不属于某个对象，由该类所有对象共享。

1、static 成员变量实现了同类对象间信息共享。

2、static 成员是在类外存储的，若求类大小，静态变量并不包含在内。

3、static 成员是命名空间属于类的全局变量，存储在 data 区的rw段。

4、static 成员只能类外初始化。

5、可以通过类名访问（无对象生成时亦可），也可以通过对象访问。

静态成员函数的意义，不在于信息共享，数据沟通，而在于管理静态数据成员，完成对静态数据成员的封装。

静态成员函数只能访问静态数据成员。原因：非静态成员函数，在调用时 this指针时被当作参数传进。而静态成员函数属于类，而不属于对象，没有 this 指针。

19、描述内存分配方式以及它们的区别?
---
1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。

2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。

3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。

int a = 0; //全局初始化区 

char *p1;//全局未初始化区 

void main(void)

{

  int b; //栈 

  char s[] = "abc"; //栈 

  char *p2; //栈 

  char *p3 = "123456"; //123456\0在常量区，p3在栈上

  static int c =0; //全局（静态）初始化区 

  p1 = (char *)malloc(10); //堆 

  p2 = (char *)malloc(20); //堆 

}


20、什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？
---
答：用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。比如new之后忘记delete，比如基类对象没有虚析构函数，delete只是delete基类对象而没有析构子类，也会内存泄漏。

* 使用的时候要记得指针的长度。
* malloc的时候得确定在那里free.
* 对指针赋值的时候应该注意被赋值指针需要不需要释放.
* 动态分配内存的指针最好不要再次赋值.

内存泄漏检测工具
---
windows下：CRT      Linux下：Valgrind 

基本原理就是重载 new和delete操作符，编译的时候调用的是dbg_new和dbg_delete，这两个重载过的操作符会在调用期间记录内存的使用情况。

```cpp
#define _CRTDBG_MAP_ALLOC 
#include<stdlib.h>
#include<crtdbg.h>

_CrtDumpMemoryLeaks();//感觉某处可能存在泄漏，通过该语句可以在某处打印当前地内存情况


程序结束之前打印泄漏信息：
一般用于全局的内存泄漏问题，在程序刚开始的时候就可以用起来。使用方法也很简单，执行下面两个语句, 先初始化, 然后设置在第几次的内存分配停住.
_CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) | _CRTDBG_LEAK_CHECK_DF);
_CrtSetBreakAlloc(long); 
```

常用的智能指针介绍？ 两个智能指针相互引用造成的内存泄漏原理？
---
https://github.com/Planck-a/skill/blob/master/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.md

21.exrern关键字的作用？      
---
答：一、 C++中调用C编译好的函数，通过extern "C" void fun(int a, int b)，告诉c++编译器在编译时按照c格式进行编译。C++语言支持函数重载，C语言不支持函数重载，函数被C++编译器编译后在库中的名字与C语言的不同，假设某个函数原型为：
          void foo(int x, inty);
	  
该函数被C编译器编译后在库中的名字为:  _foo。而C++编译器则会产生像: _foo_int_int之类的名字。为了解决此类名字匹配的问题，C++提供了C链接交换指定符号 extern "C"。

二、extern修饰变量或者函数，作用是声明函数或者变量的作用范围，如A模块中的 extern int g_Int，只要在B模块包含了A的头文件，那么B就可以正常使用，在编译阶段起作用。但是有一点要注意，在使用extern时候要严格对应声明时的格式，比如A中定义char a[6]，B中定义extern char *a，那么会报错，因为没有严格匹配。

22、int (*s[10])(int) 表示的是什么？
---
int (*s[10])(int) 函数指针数组s，每个指针指向一 int func(int param)的函数。

23、将程序跳转到指定内存地址
---
要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？
```cpp
　　*((void (*)( ))0x100000 ) ( );
　　首先要将0x100000强制转换成函数指针,即:
　　(void (*)())0x100000
　　然后再调用它:
　　*((void (*)())0x100000)();
　　用typedef可以看得更直观些:
　　typedef void(*)() voidFuncPtr;
　　*((voidFuncPtr)0x100000)();
  ```
24.STL库用过吗？常见的STL容器有哪些？算法用过哪几个？
---
答：STL包括三部分内容：容器、算法、迭代器（还有空间适配器）。（重要的还有融合这二者的迭代器）

容器，即存放数据的地方。比如array等。

在STL中，容器分为两类：序列式容器和关联式容器。

序列式容器，其中的元素不一定有序，但都可以被排序。如：vector、list、deque、stack、queue、heap、priority_queue、slist；

关联式容器，内部结构基本上是一颗平衡二叉树。所谓关联，指每个元素都有一个键值和一个实值，元素按照一定的规则存放。如：RB-tree、set、map、multiset、multimap、hashtable、hash_set、hash_map、hash_multiset、hash_multimap。

下面各选取一个作为说明。

vector：它是一个动态分配存储空间的容器。区别于c++中的array，array分配的空间是静态的，分配之后不能被改变，而vector会自动重分配（扩展）空间。Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。

注意：vector<MyString>vec;
	   vec.reserve(100);	//预先分配100个空间，vector的大小是按1 2 4 8 16 32.....的方式增长，若不预分配则会导致vec扩容时产生更多次数的拷贝构造函数。
	
set：其内部元素会根据元素的键值自动被排序。区别于map，它的键值就是实值，而map可以同时拥有不同的键值和实值。

算法，如排序，复制……以及个容器特定的算法。这点不用过多介绍，主要看下面迭代器的内容。

迭代器是STL的精髓，我们这样描述它：迭代器提供了一种方法，使它能够按照顺序访问某个容器所含的各个元素，但无需暴露该容器的内部结构。它将容器和算法分开，好让这二者独立设计。

25.头文件种的ifndef/define/endif 是干什么用的
---
      防止头文件被重复包含
      
可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。

用于子程序前加#define DEBUG用于程序调试。

应对硬件的设置（机器类型等）。

条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。

26.线程和进程的联系和区别
---
http://blog.csdn.NET/wolenski/article/details/7969908
27.线程有哪几种状态
---	
http://blog.csdn.Net/wolenski/article/details/7969908
 
28.进程间的通信方式
---
管道、命管道、信号量、共享内存、消息队列
29.线程同步和线程互斥的区别
---
http://blog.csdn.net/wolenski/article/details/7969908
 
30.线程同步的方式
---
Linux:   互斥锁、条件变量和信号量
http://blog.csdn.net/zsf8701/article/details/7844316
 
31 深拷贝和浅拷贝
---
判断是否需要自己写拷贝构造函数的标准：类中是否有指针成员变量！

调用拷贝构造函数的三种场景：

* 当出现对象的等号赋值时，会调用拷贝函数；
* 当出现把对象做函数参数进行传递时，会调用拷贝构造函数；
* 对象做函数返回值时，会调用拷贝构造函数。

在这三种场景中，如果在未显示定义拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但是若类成员变量有指针的话，会造成同一块资源释放多次，崩溃或者内存泄漏 。

浅拷贝：拷贝构造函数，赋值重载， 指针型成员变量只复制指针本身，而不复制指针所指向的目标--浅拷贝。 多个对象共用同一块资源，同一块资源释放多次，崩溃或者内存泄漏 。

深拷贝：每个对象共同拥有自己的资源，必须显式提供拷贝构造函数和赋值运算符，在这两个函数中，手动的在堆内存中另外申请空间来储存数据。

32 C++11 新特性 之右值引用、移动拷贝、移动赋值
---
https://github.com/Planck-a/skill/blob/master/C%2B%2B11%E6%96%B0%E7%89%B9%E6%80%A7.md

32 什么时候需要初始化成员列表？必须在构造函数初始化式里进行初始化的数据成员有哪些？
---
1、const成员或引用类型的成员。 因为const对象或引用类型只能初始化，不能对他们赋值。 

2  引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面

3 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化

4、调用数据成员对象或者基类的构造函数，且这个构造函数中有参数需要初始
```cpp
class Base  
{  
public:  
    Base(const string &str = "", int i = 0) : Bstr(str), _i(i) // 使用const引用避免复制,  
    // 如果只使用const则无法使用字面常量"DerivedStr"为str赋值  
    {  
        cout << "Base Constructor" << " Bstr = " << Bstr << ", _i = " << _i << endl;  
    }  
    string Bstr;  
    int _i;  
};  
class Derived : public Base  
{  
public:  
    // 调用基类构造函数，而它拥有一组参数时，要使用成员初始化列表  
    Derived() : Base("DerivedStr", 200)  // 这个是正确的  
    {  
        //Base::Bstr = "DerivedStr"; // 基类构造函数再次之前调用，这里赋值没有用。  
        //Base::_i = 200;  
        cout << "Derived Constructor" << endl;  
    }  
    string Dstr;  
};  
```
初始化列表的成员初始化顺序？

C++初始化类成员时，是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。

33  变量声明和定义
---
extern int i; //声明，不分配内存；表示多个文件共享这个变量，在其中的某个文件中分配了内存
int i; //定义 ，分配内存
External int i=1;//定义，分配内存    
引用一个已经定义的全局变量，必须用extern；或者说全局变量在外部使用声明时，extern关键字是必须的。
谨记：声明可以多次，定义只能一次。

exrern关键字的作用？ 21题     

二、extern修饰变量或者函数，作用是声明函数或者变量的作用范围，如A模块中的 extern int g_Int，只要在B模块包含了A的头文件，那么B就可以正常使用，在编译阶段起作用。但是有一点要注意，在使用extern时候要严格对应声明时的格式，比如A中定义char a[6]，B中定义extern char *a，那么会报错，因为没有严格匹配。

34 零值比较"？
---
bool类型：if(flag)
int类型：if(flag == 0)
指针类型：if(flag == null)
float类型：if((flag >= -0.000001) && (flag <= 0. 000001)) //float不能直接比较 a==0
 

35 strlen和sizeof区别？
---
strlen是函数，找到\0就停止；

sizeof是运算符，得到的是分配了多大的内存，传入数组指针时参数不退化，在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。

36 结构体内存对齐
---
什么是对齐：在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。（举例：对于32位系统，如果int型的起始地址为偶地址，那么一个周期可以读取；如果放在奇地址，需要两个周期，效率低）

（1）结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同；

（2）结构体变量中成员的偏移量必须是成员大小的整数倍。按照此规则一次计算每个变量的偏移量；

（3）结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。但由于结构体总的大小必须是各个成员大小的整数倍，所以需要判断，小的话要补齐

（4）未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。
```cpp
计算过程：
　struct stu3
　　{
　　char c1;//偏移量为0符合要求
　　int i;//偏移量为1， 结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍），故偏移量应为4
　　char c2;//偏移量为8（偏移量4+int大2小4），符合要求
}
```
  算出sizeof( stu3 )=1+8=9，但9不是int的整数倍故最终大小为12。
  
37、#define 宏定义
---
（1）宏定义和const区别？

宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。

宏不检查类型；const会检查数据类型。

宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。

（2）宏定义和typedef区别？

宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。

宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。

宏不检查类型；typedef会检查数据类型。

宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。

注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

（3）宏定义和内联函数(inline)区别？

在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。

内联函数本身是函数，强调函数特性，具有重载等功能。

内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。

38 、volatile有什么作用？   --------》explicit
---
volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。
多线程中被几个任务共享的变量需要定义为volatile类型。

39、数组名和指针
---
数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。

当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

40、野指针
---
不是指向null的指针，是指向垃圾内存的指针。

（1）指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

（2）指针free或delete之后没有及时置空 => 释放操作后立即置空。

41、类对象的内存大小
---
（1）非静态成员的数据类型大小之和。

（2）编译器加入的额外成员变量（如指向虚函数表的指针）。

（3）为了边缘对齐优化加入的padding。

42、构造函数调用顺序，析构函数呢？
---
调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅

基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。

如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。

成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。
派生类的构造函数。析构函数与之相反。
43、怎么限制一个类的对象实例,只能在"堆"上分配,或者只能在"栈"上分配
---
定义类对象有两种方式，A a和A *a=new A；

限制只在堆上分配内存：即只能用new,不能直接定义。

做法：将析构函数设为私有，类对象就无法建立在栈上了，如果直接使用A  a 来建立对象，编译报错，提示析构函数无法访问，只能使用new操作符来建立对象。

缺点1：必须自己手动打造destory函数来析构对象，而不能用delete。     

缺点2：析构函数做成私有的话，无法正常继承---》析构函数写出protected的对比

缺点：

1 new和destory搭配问题

2、继承问题

限制只在堆上分配内存：
只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可。代码如下：

43、strcpy 有什么危险？
---
答：strcpy 不检查copy目标串的Size，如果目标空间不够，就有BufferOverflow问题。如果在用的时候加上相关的长度判断，则会大大降低出此错误的危险。

char *strcpy(char *dest,const char *src); 

VS2005开始已经推出相应的安全版本——strcpy_s（末尾的s可能代表safe）。他们在接口增加了：

1、一个参数numElems来表明dest中的字节数，防止目标指针dest中的空间不够而导致出现Bug，

2、返回值改成返回错误代码，而不是为了一些所谓的方便而返回char*。这样接口的定义就比原来安全很多。

strncpy

strncpy(dest, src, sizeof(dest))；//链式编程，返回值是des

dest[sizeof(dest)-1] = ‘\0’;//务必要把dest的最后一个字节手工设置为0. 因为strncpy仅在src的长度小于dest时，对剩余的字节填0；如果des较小时，手动在最后一位补\0并覆盖最后一位。

44、怎么判断两个struct相等？
---
答：我会选择重载==运算符，逐一比较成员变量是否相等；

那能不能用内存比较memcmp来判断呢？

A：不能，涉及字节对齐，可能有内存间隙，这里的值是随机的

45、局部变量能否和全局变量重名？如果能，请说明系统如何处理；如果不能，请说明原因？
---
答案：在程序中如果出现了相同的两个变量，一个是局部变量，一个是全局变量，编译可以通过，但是打印出的值是局部变量的值，如果想打印全局变量的值的话，在全局变量之前加上“：：”就可以了。
```cpp
  int a = 3;      //定义局部变量并赋值
  cout<<"a = "<<a<<endl;
  ::a = 2;    //给全局变量赋值
  cout<<"a = "<<::a<<endl;
  ```
46、struct和class 的区别
---
`c++中`

1.不同点

 	          struct	       class
	     
默认继承权限	     public              private

默认数据访问控制   public	        private

模板参数	      不能定义	       可以用于定义模板参数

2.相同点

可以继承，有数据成员，方法，构造函数等。成员都可以为public，protected，private

`C中`

struct没有函数成员
struct没有private、public、protected访问权限限定
struct没有继承关系

47、struct 和union的区别
---
* 所有成员函数共用内存块
* 共用体的大小为共用体中成员变量最大的那个。
* 在任意时刻，共用体中只存放了一个成员。
* 对公用体的成员赋值，将会对其他成员冲击，原来的成员值就不在了。
48、虚拟内存
---
虚拟内存是为了把不用的放到外存，等到需要时再调入内存

虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或“永久”的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：

① 请求分页存储管理。
② 请求分段存储管理。
③ 请求段页式存储管理。

49.栈溢出问题
---
栈溢出：栈内存一般就2M，如果定义
EasyTcpClient client[10];//client类数组，如果每个类的有100kb的话，10个就会爆炸

//正确的方式：
EasyTcpClient *client[10];//client类指针数组，用new在堆上分配内存
for(int i=0;i<10;i++)
{
    client[n]=new EasyTcpClient;
}


50、C++如何在main之前执行调用函数？
---
```cpp
答：（1）全局对象、静态对象的构造函数在main( )函数之前执行。
(2)static func * before1[] = { before_main1 };  
(3)int g_iValue = func();
(4)linux下：
_attribute__((destructor)) void after_main() { 
  printf("after main\n"); }
（5）main函数之后：
_onexit_t _func{
   _onexit_t function
};
```
51、虚函数、多重继承和虚继承
---
[虚函数和虚继承](https://github.com/Planck-a/skill/blob/master/C%2B%2B/%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E7%BB%A7%E6%89%BF.md)

52 C++11支持的四种类型转换
---
static_cast, dynamic_cast, const_cast, reinterpret_cast

const_cast用于将const变量转为非const

static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态想上转化，如果向下转能成功但是不安全，结果未知；

dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。

reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；

为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。
    
