
1、进程与线程比较
---
（1）进程和线程的关系

   进程是资源分配的基本单位，线程是调度的基本单位；从内存角度来讲，多进程中，所有的子进程拥有各自的内存空间，对32位系统而言也就是完整的4G虚拟地址；而对于一个进程中的多个线程，所有线程工用进程的内存空间。


（2）父进程和子进程的关系？子进程复制了父进程的那些东西？PCB？

答：子进程复制了父进程的所有数据(代码段、数据段、BSS、堆、栈)，但是从内存的角度来讲，子进程拥有和父进程相同的虚地址，这就解释了同一段地址却存储不同的值。每一个进程产生都有自己的虚拟地址空间，映射到不同的物理空间。多进程时，子进程复制了父进程的虚拟地址，虽然虚拟地址相同，但是映射的物理空间却是不一样的，&操作返回的是虚拟地址。

每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。

```cpp

main(){
    char str[4]="asd";
    pid_t pid=fork();
    if(pid==0){
        str[0]='b';
        printf("子进程中str=%s\n",str);
        printf("子进程中str指向的首地址:%x\n",(unsigned int)str);
    }
    else{
        sleep(1);
        printf("父进程中str=%s\n",str);
        printf("父进程中str指向的首地址:%x\n",(unsigned int)str);
    }

```

补充：`写时复制`-------->实际情况

fork之后，子进程并不是一次性地复制父进程的所有东西，这样效率太低。

一般CPU都是以“页”为单位分配空间的，像Intel的CPU，其一页在通常情况下是4K字节大小，而无论是数据段还是堆栈段都是由许多“页”构成的，fork函数复制这两个段，只是“逻辑”上的，并非“物理”上的，也就是说，实际执行fork()时，物理空间上两个进程的数据段和堆栈段都还是共享着的，都是指向同一片物理地址。当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的“页”从物理上也分开。


（3）fork和vfork，以及clone的关系？
答：
* fork()是将父进程的全部资源复制给了子进程。会复制父进程的地址空间、已打开文件描述符、命名空间
* clone只是复制了一小部分必要的资源。在调用clone时可以通过参数控制要复制的对象。---->pthread_create中就是调用了clone创建子线程
* vfork与fork的区别是，vfork共享父进程的地址空间，一般采用vfork()的子进程，都会紧接着执行execv启动一个全新的进程，该进程的进程空间与父进程完全独立不相干，所以不需要复制父进程资源空间，因为vfork主要用于为了让子进程exec，exec之后子进程会用新程序的数据将内存重新刷一遍，这样它就有了自己的地址空间。子进程exec之后返回，这个时候父进程就认为子进程“结束”了，自己开始运行。实际上子进程继续在一个完全独立的空间运行着。举个例子，比如在一个聊天程序中，弹出了一个视频播放器。你说视频播放器要继承你的聊天程序的进程空间的资源干嘛？

（4）进程和线程的优缺点，各适用于什么场合？
答：

（5）多进程和多线程？
答：场景1：主进程accpet()返回客户端sock，这时由于子进程复制父进程的栈空间，然后在子进程中copy一份，所以在子进程中可以直接对sock进行操作，哪怕此时父进程改变sock的值；但是对于主线程而言，由于子线程没有自己的栈空间，只是共用父线程的空间，所以如果子线程在读取sock时父线程接受了另一个客户端请求覆盖了该值，则子线程无法继续处理上一次的连接任务了。改进的办法是子线程立马复制val的值在自己的栈区，但父线程必须保证子线程复制动作完成之后再执行新的accept()。这又得发生线程间通信，子线程复制完成后主动通知父线程。
场景2：多进程环境间完全独立，要实现通信的话就得采用进程间的通信方式，它们通常都是耗时间的。而线程则不用任何手段数据就是共享的。当然多个子线程在同时执行写入操作时需要实现互斥，否则数据就写“脏”了。

（6）信号量和mutex




2、进程间通信
---
进程间的通信方式有这样几种：

A.共享内存    B.消息队列    C.信号量    D.有名管道    E.无名管道    F.信号

G.文件        H.socket

线程间的通信方式上述进程间的方式都可沿用，且还有自己独特的几种：

A.互斥量      B.自旋锁      C.条件变量  D.读写锁      E.线程信号

G.全局变量

进程间通信分为两大类，第一类是在一台主机上的不同进程：管道、命名管道、消息队列、共享内存、信号量、信号
第二类是在两台主机上：socket
管道是在父子进程中通信的，是半双工的，如果需要全双工，那么就需要建立两个管道
命名管道是在不相关的进程之间，通过管道号进行通信，也是半双工
消息队列：双方协商好传递消息的数据类型，通过key进行连接。key值属于要通信的进程双方互相沟通好的，作为在内核里找到它们专属的消息队列的桥梁。
共享内存：唯一不在内核缓存区进行的通信，所以速度也是最快的，开发中最常用的。
```cpp
消息队列   最大长度64k，最大16条
int msgget(key_t key，int msgflag);
//创建消息队列或者获取消息队列,key是队列名，msgflag是9位权限位 rwx rwx rwx

int main1()
{
    int msgqid=msgget(0x1234,0666);//创建消息队列或者获取消息队列
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；//没有指定创建且没有消息队列返回
    } 
}
int main2()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT);//指定创建
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int main3()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT|IPC_EXCL);//开发中优先用这个
    //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int msgctl();
int main4()
{
    int msgqid=msgget(0x1234,0666);
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
    struct msqid_ds buf;
    int ret = magctl(msgid,IPC_STAT,&buf);//传出到buf中，获取对消息队列的控制
}
int msgsnd();
int msgrcv();
```
```cpp
管道======》都是linux内核的缓冲区
管道是半双工的，如果双方需要通信，那么就建立两个管道
管道的读写可以设置成阻塞/非阻塞
int main()
{
    int pipefd[2];
    int ret=pipe(pipefd);//创建管道，fd1写，fd0读
    int pid=fork();
    if(pid == 0)
    {
        close(pipefd[0]);
        write(pipefd[1],"hdsjdskjhdsjk",6);//rw
        close(pipefd[1]);
    }
    close(pipefd[1]);
    char buf[1024]={0};
    int n=read(pipefd[0],buf,sizeof(buf));
    close(pipefd[0]);
}

设置非阻塞：
int flag= fcntl(int fd, F_GETFL);//第二个命令cmd是指get set
flag= flag| O_NONBLOCK;
int ret=fcntl( fd, F_SETFL,flag);
```
```cpp
共享内存   ====》不陷入内核，读写涉及加锁，和信号量放在一起
将内核中的缓冲区映射到用户空间，可以选择修改后是否重新同步给内核缓冲区
ipcs-------> nattach  表示有多少个进程连接这个共享内存了


int main3()
{
   int shmid= shmget(0x2234,sizeof(Teacher),0666|IPC_CREAT|IPC_EXCL);
   //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("共享内存不存在")；
    }
    Teacher *p=NULL;
    P=shmat(shmid,NULL,0);//映射到用户空间，p就是共享内存的首地址
}
```

3、虚拟内存和物理内存
---
虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。

假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0~0xFFFFFFFF（4G）的地址空间，但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？

答：计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（page frame），这个页和页帧的大小是一样大的，但是虚拟内存页的个数 > 物理内存页帧的个数。在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射。操作系统有个页面失效（page fault）功能。当缺页中断时，操作系统通过页面置换算法 找到一个最少使用的页帧（物理内存中），让他失效，并把它写入磁盘（临时保存一下），随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。这就是处理虚拟内存地址到物理内存的步骤。

虚拟内存地址由页号和偏移量组成，那么先把页号映射到页帧，然后在页帧+偏移量组成物理上真正存在的地址。

补充：
`top中虚拟内存VIRT和RES常驻内存的关系？`
VIRT：
进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等；如果new了100M，但是我现在只往里面写1M，这时VIRT增加100M，RES增加1M
RES:
malloc了100M的内存，但是只给其中里面写1M，则RES增加1M
```cpp
#include <iostream>
 
int main()
{
    char * p = new char [1024*1024*512];
    getchar();
    return 0;
 }
 
top结果如下：
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
401 huyiyang  17   0  523m  916  792 S  0.0  0.0   0:00.00 ./main
```
```cpp
#include <iostream>
 
int main()
{
    char * p = new char [1024*1024*512];
    memset(p, 0, 1024*1024*512);
    getchar();
    return 0;
}
top结果如下：
PID   USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  
32604 huyiyang  17   0  523m  512m  792 S  0.0 26.2   0:00.33 ./main
```
4、操作系统常用的调度算法
---
（1）批处理作业调度算法
   
   1、先来先服务调度算法（FCFS）  优点公平，缺点短作业饿死
      
   2、短作业优先调度算法(SPF)     长作业不满
     
   3、最高响应比优先算法(HRN)     响应比＝（等待时间＋运行时间）/运行时间，权衡等待时间和运行时间
     
   4、基于优先数调度算法(HPF)     加入优先级
     
   5、均衡调度算法，即多级队列调度算法

（2）进程调度算法

   1、先进先出算法      针对就绪队列中的进程而言，比如一个进程没有拿到锁进入就绪队列中
      
   2、时间片轮转算法     分时系统的一种调度算法
      
   3、最高优先级算法(HPF)   优先级
      
   4、多级队列反馈法
      
（3）虚拟页式存储管理中的页面置换算法
  
   1、先进先出页面置换算法    最早进入内存的页面先失效
     
   2、最近最久未使用算法
      
   3、最少使用算法
   
   
5、进程同步与互斥
---

