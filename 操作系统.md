
1、进程与线程比较
---
（1）进程和线程的关系

   进程是资源分配的基本单位，线程是调度的基本单位；从内存角度来讲，多进程中，所有的子进程拥有各自的内存空间，对32位系统而言也就是完整的4G虚拟地址；而对于一个进程中的多个线程，所有线程工用进程的内存空间。


（2）父进程和子进程的关系？子进程复制了父进程的那些东西？PCB？

答：子进程复制了父进程的所有数据(代码段、数据段、BSS、堆、栈)，但是从内存的角度来讲，子进程拥有和父进程相同的虚地址，这就解释了同一段地址却存储不同的值。每一个进程产生都有自己的虚拟地址空间，映射到不同的物理空间。多进程时，子进程复制了父进程的虚拟地址，虽然虚拟地址相同，但是映射的物理空间却是不一样的，&操作返回的是虚拟地址。

每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。

```cpp

main(){
    char str[4]="asd";
    pid_t pid=fork();
    if(pid==0){
        str[0]='b';
        printf("子进程中str=%s\n",str);
        printf("子进程中str指向的首地址:%x\n",(unsigned int)str);
    }
    else{
        sleep(1);
        printf("父进程中str=%s\n",str);
        printf("父进程中str指向的首地址:%x\n",(unsigned int)str);
    }

```

补充：`写时复制`-------->实际情况

fork之后，子进程并不是一次性地复制父进程的所有东西，这样效率太低。

一般CPU都是以“页”为单位分配空间的，像Intel的CPU，其一页在通常情况下是4K字节大小，而无论是数据段还是堆栈段都是由许多“页”构成的，fork函数复制这两个段，只是“逻辑”上的，并非“物理”上的，也就是说，实际执行fork()时，物理空间上两个进程的数据段和堆栈段都还是共享着的，都是指向同一片物理地址。当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的“页”从物理上也分开。


（3）fork和vfork，以及clone的关系？
答：
* fork()是将父进程的全部资源复制给了子进程。会复制父进程的地址空间、已打开文件描述符、命名空间
* clone只是复制了一小部分必要的资源。在调用clone时可以通过参数控制要复制的对象。---->pthread_create中就是调用了clone创建子线程
* vfork与fork的区别是，vfork共享父进程的地址空间，一般采用vfork()的子进程，都会紧接着执行execv启动一个全新的进程，该进程的进程空间与父进程完全独立不相干，所以不需要复制父进程资源空间，因为vfork主要用于为了让子进程exec，exec之后子进程会用新程序的数据将内存重新刷一遍，这样它就有了自己的地址空间。子进程exec之后返回，这个时候父进程就认为子进程“结束”了，自己开始运行。实际上子进程继续在一个完全独立的空间运行着。举个例子，比如在一个聊天程序中，弹出了一个视频播放器。你说视频播放器要继承你的聊天程序的进程空间的资源干嘛？

（4）进程和线程的优缺点，各适用于什么场合？
答：

（5）多进程和多线程？
答：场景1：主进程accpet()返回客户端sock，这时由于子进程复制父进程的栈空间，然后在子进程中copy一份，所以在子进程中可以直接对sock进行操作，哪怕此时父进程改变sock的值；但是对于主线程而言，由于子线程没有自己的栈空间，只是共用父线程的空间，所以如果子线程在读取sock时父线程接受了另一个客户端请求覆盖了该值，则子线程无法继续处理上一次的连接任务了。改进的办法是子线程立马复制val的值在自己的栈区，但父线程必须保证子线程复制动作完成之后再执行新的accept()。这又得发生线程间通信，子线程复制完成后主动通知父线程。
场景2：多进程环境间完全独立，要实现通信的话就得采用进程间的通信方式，它们通常都是耗时间的。而线程则不用任何手段数据就是共享的。当然多个子线程在同时执行写入操作时需要实现互斥，否则数据就写“脏”了。

（6）信号量和mutex




2、进程间通信
---
进程间的通信方式有这样几种：

A.共享内存    B.消息队列    C.信号量    D.有名管道    E.无名管道    F.信号

G.文件        H.socket

线程间的通信方式上述进程间的方式都可沿用，且还有自己独特的几种：

A.互斥量      B.自旋锁      C.条件变量  D.读写锁      E.线程信号

G.全局变量

进程间通信分为两大类，第一类是在一台主机上的不同进程：管道、命名管道、消息队列、共享内存、信号量、信号
第二类是在两台主机上：socket
管道是在父子进程中通信的，是半双工的，如果需要全双工，那么就需要建立两个管道
命名管道是在不相关的进程之间，通过管道号进行通信，也是半双工
消息队列：双方协商好传递消息的数据类型，通过key进行连接。key值属于要通信的进程双方互相沟通好的，作为在内核里找到它们专属的消息队列的桥梁。
共享内存：唯一不在内核缓存区进行的通信，所以速度也是最快的，开发中最常用的。
```cpp
消息队列   最大长度64k，最大16条
int msgget(key_t key，int msgflag);
//创建消息队列或者获取消息队列,key是队列名，msgflag是9位权限位 rwx rwx rwx

int main1()
{
    int msgqid=msgget(0x1234,0666);//创建消息队列或者获取消息队列
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；//没有指定创建且没有消息队列返回
    } 
}
int main2()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT);//指定创建
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int main3()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT|IPC_EXCL);//开发中优先用这个
    //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int msgctl();
int main4()
{
    int msgqid=msgget(0x1234,0666);
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
    struct msqid_ds buf;
    int ret = magctl(msgid,IPC_STAT,&buf);//传出到buf中，获取对消息队列的控制
}
int msgsnd();
int msgrcv();
```
```cpp
管道======》都是linux内核的缓冲区
管道是半双工的，如果双方需要通信，那么就建立两个管道
管道的读写可以设置成阻塞/非阻塞
int main()
{
    int pipefd[2];
    int ret=pipe(pipefd);//创建管道，fd1写，fd0读
    int pid=fork();
    if(pid == 0)
    {
        close(pipefd[0]);
        write(pipefd[1],"hdsjdskjhdsjk",6);//rw
        close(pipefd[1]);
    }
    close(pipefd[1]);
    char buf[1024]={0};
    int n=read(pipefd[0],buf,sizeof(buf));
    close(pipefd[0]);
}

设置非阻塞：
int flag= fcntl(int fd, F_GETFL);//第二个命令cmd是指get set
flag= flag| O_NONBLOCK;
int ret=fcntl( fd, F_SETFL,flag);
```
```cpp
共享内存   ====》不陷入内核，读写涉及加锁，和信号量放在一起
将内核中的缓冲区映射到用户空间，可以选择修改后是否重新同步给内核缓冲区
ipcs-------> nattach  表示有多少个进程连接这个共享内存了


int main3()
{
   int shmid= shmget(0x2234,sizeof(Teacher),0666|IPC_CREAT|IPC_EXCL);
   //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("共享内存不存在")；
    }
    Teacher *p=NULL;
    P=shmat(shmid,NULL,0);//映射到用户空间，p就是共享内存的首地址
}
```

3、虚拟内存和物理内存
---
虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。

假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0~0xFFFFFFFF（4G）的地址空间，但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？

答：计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（page frame），这个页和页帧的大小是一样大的，但是虚拟内存页的个数 > 物理内存页帧的个数。在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射。操作系统有个页面失效（page fault）功能。当缺页中断时，操作系统通过页面置换算法 找到一个最少使用的页帧（物理内存中），让他失效，并把它写入磁盘（临时保存一下），随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。这就是处理虚拟内存地址到物理内存的步骤。

虚拟内存地址由页号和偏移量组成，那么先把页号映射到页帧，然后在页帧+偏移量组成物理上真正存在的地址。

32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。

补充：
`top中虚拟内存VIRT和RES常驻内存的关系？`
VIRT：
进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等；如果new了100M，但是我现在只往里面写1M，这时VIRT增加100M，RES增加1M
RES:
malloc了100M的内存，但是只给其中里面写1M，则RES增加1M
```cpp
#include <iostream>
 
int main()
{
    char * p = new char [1024*1024*512];
    getchar();
    return 0;
 }
 
top结果如下：
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
401 huyiyang  17   0  523m  916  792 S  0.0  0.0   0:00.00 ./main
```
```cpp
#include <iostream>
 
int main()
{
    char * p = new char [1024*1024*512];
    memset(p, 0, 1024*1024*512);
    getchar();
    return 0;
}
top结果如下：
PID   USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  
32604 huyiyang  17   0  523m  512m  792 S  0.0 26.2   0:00.33 ./main
```
4、操作系统常用的调度算法
---
（1）批处理作业调度算法
   
   1、先来先服务调度算法（FCFS）  优点公平，缺点短作业饿死
      
   2、短作业优先调度算法(SPF)     长作业不满
     
   3、最高响应比优先算法(HRN)     响应比＝（等待时间＋运行时间）/运行时间，权衡等待时间和运行时间
     
   4、基于优先数调度算法(HPF)     加入优先级
     
   5、均衡调度算法，即多级队列调度算法

（2）进程调度算法

   1、先进先出算法      针对就绪队列中的进程而言，比如一个进程没有拿到锁进入就绪队列中
      
   2、时间片轮转算法     分时系统的一种调度算法
      
   3、最高优先级算法(HPF)   优先级
      
   4、多级队列反馈法
      
（3）虚拟页式存储管理中的页面置换算法
  
   1、先进先出页面置换算法    最早进入内存的页面先失效
     
   2、最近最久未使用算法
      
   3、最少使用算法
   
   
5、进程同步与互斥
---
原子操作、信号量机制、自旋锁管程、会合、分布式系统
6、线程同步的方式
---
（1）临界区  CCriticalSection
```cpp
CcriticalSection g_CriticalSection;
g_CriticalSection.Lock（）；
g_CriticalSection.Unlock（）；
```
（2）信号量
```cpp

```
（3）互斥量
 
（4）条件变量（事件）:通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

7、死锁
---
（1）什么是死锁？死锁产生的条件？

在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。死锁产生的四个条件（有一个条件不成立，则不会产生死锁）
* 互斥条件：一个资源一次只能被一个进程使用
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
* 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
* 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

（2）死锁的处理策略：

解决死锁的基本方法如下：预防死锁、避免死锁、检测死锁、解除死锁（破坏四个条件之一）

8、动态链接库与静态链接库的区别
---
9、中断与系统调用
---
