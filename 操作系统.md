
1、进程与线程比较
---
（1）进程和线程的关系

   进程是资源分配的基本单位，线程是调度的基本单位；从内存角度来讲，多进程中，所有的子进程拥有各自的内存空间，对32位系统而言也就是完整的4G虚拟地址；而对于一个进程中的多个线程，所有线程工用进程的内存空间。


（2）父进程和子进程的关系？子进程复制了父进程的那些东西？PCB？

答：子进程复制了父进程的所有数据(代码段、数据段、BSS、堆、栈)，但是从内存的角度来讲，子进程拥有和父进程相同的虚地址，这就解释了同一段地址却存储不同的值。每一个进程产生都有自己的虚拟地址空间，映射到不同的物理空间。多进程时，子进程复制了父进程的虚拟地址，虽然虚拟地址相同，但是映射的物理空间却是不一样的，&操作返回的是虚拟地址。

每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。

```cpp

main(){
    char str[4]="asd";
    pid_t pid=fork();
    if(pid==0){
        str[0]='b';
        printf("子进程中str=%s\n",str);
        printf("子进程中str指向的首地址:%x\n",(unsigned int)str);
    }
    else{
        sleep(1);
        printf("父进程中str=%s\n",str);
        printf("父进程中str指向的首地址:%x\n",(unsigned int)str);
    }

```

补充：`写时复制`-------->实际情况

fork之后，子进程并不是一次性地复制父进程的所有东西，这样效率太低。

一般CPU都是以“页”为单位分配空间的，像Intel的CPU，其一页在通常情况下是4K字节大小，而无论是数据段还是堆栈段都是由许多“页”构成的，fork函数复制这两个段，只是“逻辑”上的，并非“物理”上的，也就是说，实际执行fork()时，物理空间上两个进程的数据段和堆栈段都还是共享着的，都是指向同一片物理地址。当有一个进程写了某个数据时，这时两个进程之间的数据才有了区别，系统就将有区别的“页”从物理上也分开。


（3）fork和vfork，以及clone的关系？
答：
* fork()是将父进程的全部资源复制给了子进程。会复制父进程的地址空间、已打开文件描述符、命名空间
* clone只是复制了一小部分必要的资源。在调用clone时可以通过参数控制要复制的对象。---->pthread_create中就是调用了clone创建子线程
* vfork与fork的区别是，vfork共享父进程的地址空间，一般采用vfork()的子进程，都会紧接着执行execv启动一个全新的进程，该进程的进程空间与父进程完全独立不相干，所以不需要复制父进程资源空间，因为vfork主要用于为了让子进程exec，exec之后子进程会用新程序的数据将内存重新刷一遍，这样它就有了自己的地址空间。子进程exec之后返回，这个时候父进程就认为子进程“结束”了，自己开始运行。实际上子进程继续在一个完全独立的空间运行着。举个例子，比如在一个聊天程序中，弹出了一个视频播放器。你说视频播放器要继承你的聊天程序的进程空间的资源干嘛？

（4）进程和线程的优缺点，各适用于什么场合？
答：

（5）多进程和多线程？
答：场景1：主进程accpet()返回客户端sock，这时由于子进程复制父进程的栈空间，然后在子进程中copy一份，所以在子进程中可以直接对sock进行操作，哪怕此时父进程改变sock的值；但是对于主线程而言，由于子线程没有自己的栈空间，只是共用父线程的空间，所以如果子线程在读取sock时父线程接受了另一个客户端请求覆盖了该值，则子线程无法继续处理上一次的连接任务了。改进的办法是子线程立马复制val的值在自己的栈区，但父线程必须保证子线程复制动作完成之后再执行新的accept()。这又得发生线程间通信，子线程复制完成后主动通知父线程。
场景2：多进程环境间完全独立，要实现通信的话就得采用进程间的通信方式，它们通常都是耗时间的。而线程则不用任何手段数据就是共享的。当然多个子线程在同时执行写入操作时需要实现互斥，否则数据就写“脏”了。

（6）信号量和mutex




2、进程间通信
---
进程间的通信方式有这样几种：

A.共享内存    B.消息队列    C.信号量    D.有名管道    E.无名管道    F.信号

G.文件        H.socket

线程间的通信方式上述进程间的方式都可沿用，且还有自己独特的几种：

A.互斥量      B.自旋锁      C.条件变量  D.读写锁      E.线程信号

G.全局变量

进程间通信分为两大类，第一类是在一台主机上的不同进程：管道、命名管道、消息队列、共享内存、信号量、信号
第二类是在两台主机上：socket
管道是在父子进程中通信的，是半双工的，如果需要全双工，那么就需要建立两个管道
命名管道是在不相关的进程之间，通过管道号进行通信，也是半双工
消息队列：双方协商好传递消息的数据类型，通过key进行连接。key值属于要通信的进程双方互相沟通好的，作为在内核里找到它们专属的消息队列的桥梁。
共享内存：唯一不在内核缓存区进行的通信，所以速度也是最快的，开发中最常用的。
```cpp
消息队列   最大长度64k，最大16条
int msgget(key_t key，int msgflag);
//创建消息队列或者获取消息队列,key是队列名，msgflag是9位权限位 rwx rwx rwx

int main1()
{
    int msgqid=msgget(0x1234,0666);//创建消息队列或者获取消息队列
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；//没有指定创建且没有消息队列返回
    } 
}
int main2()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT);//指定创建
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int main3()
{
    int msgqid=msgget(0x1234,0666|IPC_CREAT|IPC_EXCL);//开发中优先用这个
    //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
}
int msgctl();
int main4()
{
    int msgqid=msgget(0x1234,0666);
    if(errno == ENOENT)
    {
        printf("消息队列不存在")；
    } 
    struct msqid_ds buf;
    int ret = magctl(msgid,IPC_STAT,&buf);//传出到buf中，获取对消息队列的控制
}
int msgsnd();
int msgrcv();
```
```cpp
管道======》都是linux内核的缓冲区
管道是半双工的，如果双方需要通信，那么就建立两个管道
管道的读写可以设置成阻塞/非阻塞
int main()
{
    int pipefd[2];
    int ret=pipe(pipefd);//创建管道，fd1写，fd0读
    int pid=fork();
    if(pid == 0)
    {
        close(pipefd[0]);
        write(pipefd[1],"hdsjdskjhdsjk",6);//rw
        close(pipefd[1]);
    }
    close(pipefd[1]);
    char buf[1024]={0};
    int n=read(pipefd[0],buf,sizeof(buf));
    close(pipefd[0]);
}

设置非阻塞：
int flag= fcntl(int fd, F_GETFL);//第二个命令cmd是指get set
flag= flag| O_NONBLOCK;
int ret=fcntl( fd, F_SETFL,flag);
```
```cpp
共享内存   ====》不陷入内核，读写涉及加锁，和信号量放在一起
将内核中的缓冲区映射到用户空间，可以选择修改后是否重新同步给内核缓冲区
ipcs-------> nattach  表示有多少个进程连接这个共享内存了


int main3()
{
   int shmid= shmget(0x2234,sizeof(Teacher),0666|IPC_CREAT|IPC_EXCL);
   //不存在则创建，存在则提醒已经存在
    if(errno == ENOENT)
    {
        printf("共享内存不存在")；
    }
    Teacher *p=NULL;
    P=shmat(shmid,NULL,0);//映射到用户空间，p就是共享内存的首地址
}
```

3、虚拟内存和物理内存
---
虚拟内存地址的大小是与地址总线位数相关，物理内存地址的大小跟物理内存条的容量相关。

假设你的计算机是32位，那么它的地址总线是32位的，也就是它可以寻址0~0xFFFFFFFF（4G）的地址空间，但如果你的计算机只有256M的物理内存0x~0x0FFFFFFF（256M），同时你的进程产生了一个不在这256M地址空间中的地址，那么计算机该如何处理呢？

答：计算机会对虚拟内存地址空间（32位为4G）分页产生页（page），对物理内存地址空间（假设256M）分页产生页帧（page frame），这个页和页帧的大小是一样大的，但是虚拟内存页的个数 > 物理内存页帧的个数。在计算机上有一个页表（page table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射。操作系统有个页面失效（page fault）功能。当缺页中断时，操作系统通过页面置换算法 找到一个最少使用的页帧（物理内存中），让他失效，并把它写入磁盘（临时保存一下），随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了。这就是处理虚拟内存地址到物理内存的步骤。

虚拟内存地址由页号和偏移量组成，那么先把页号映射到页帧，然后在页帧+偏移量组成物理上真正存在的地址。

32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。

linux的内存管理-----伙伴关系+slab
---
`伙伴关系`
为了减少外部碎片，把所有的空闲页面分为大小不同的十个页块，其中每个页块的大小为2幂次个页（4K*2^n），把这些页块用链表相连。每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页框块。

（1）页块框地起始地址：
每个页块的第一个页的物理地址是该块大小的整数倍。例如，大小为16个页的块，其起始地址是16*2^12（2^12=4096）的整数倍。

（2）分配页块时：
假设要申请一个256个页的块，先从256个页的链表中查找空闲块，如果没有，就去512个页的链表中找，找到了则将页块分为2个256个页的块，一个分配给应用，另外一个移到256个页的链表中。如果512不存在，接着往上找，如果1024块存在，则将其中的256页作为请求返回，剩余的768分成256块和512块分别插到相应的链表中。如果仍然没有，则返回错误。

（3）页框块在释放时：
会迭代地主动合成为2倍大的单独页框块。两个块称为伙伴需要满足一下条件：
        （1）两个块具有相同的大小
       （2）它们的物理地址是连连续的。
       （3）第一块的第一个页框的物理地址是2*b*2^12的倍数。
       
（4）页块数组的数据结构：
    
 包含一个11元素、元素类型为free_area的一个数组，每个元素对应一块大小。
    
 free_area每个元素中有一个free_list，表示双向循环链表的头，这个双向循环链表集中了大小为2^k页的空闲块对应的页描述符。该链表包含每个空闲页框块（大小为2^k）的起始页框的页描述符。指向链表中相邻元素的指针存放在页描述符的lru字段中。
      
   free_area每个元素还包含一个nr_free字段，它指定了大小为2^k的页框块个数。当然，如果没有大小为2^k的空闲页框块，则nr_free等于0且free_list为空。
          
   一个空闲块的第一个页的描述符的private字段存放了块的order，也就是k。正式由于这个字段，当页框被释放时，内核可以确定这个块的伙伴是否也空闲。如果是的话就可以把两个块合成一个2^(i+1)的块。
   
`slab`
物理内存也是页，每个页大小固定4k，分配时不必是连续地址，但是要尽量选择连续的地址。为了尽量减少不连续情况，采用了“伙伴”关系来管理空闲页面，分配页面必须是2的幂次个页面（1、2、4、8…512页）。内核自身最常使用的内存往往是很小的，比如存放文件描述符、进程描述符、虚拟内存区域描述符等行为所需的内存都远小于一页，用一整个4k内存太浪费，于是提出了slab。Slab在伙伴关系分配的4k内存基础上，将页面（来自于伙伴关系管理的空闲页面链表）撕碎成众多小内存块以供分配，而且当被使用完后，并不直接释放而是被缓存到“存储池”里。伙伴关系可以减小外部碎片，slab可以减小内部碎片
（类似项目中自己实现的内存池＋对象池关系）
          
补充：
`top中虚拟内存VIRT和RES常驻内存的关系？`
VIRT：
进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据，以及malloc、new分配的堆空间和分配的栈空间等；如果new了100M，但是我现在只往里面写1M，这时VIRT增加100M，RES增加1M
RES:
malloc了100M的内存，但是只给其中里面写1M，则RES增加1M
```cpp
#include <iostream>
 
int main()
{
    char * p = new char [1024*1024*512];
    getchar();
    return 0;
 }
 
top结果如下：
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
401 huyiyang  17   0  523m  916  792 S  0.0  0.0   0:00.00 ./main
```
```cpp
#include <iostream>
 
int main()
{
    char * p = new char [1024*1024*512];
    memset(p, 0, 1024*1024*512);
    getchar();
    return 0;
}
top结果如下：
PID   USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND  
32604 huyiyang  17   0  523m  512m  792 S  0.0 26.2   0:00.33 ./main
```
4、进程的内存管理
---
![示意图](https://github.com/Planck-a/image-folder/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/usage.png)
进程用的4G虚拟内存，多个进程创建多个内存空间；这些个空间由一个vm_area_strcut类型的链表链起来，然后在4G地址空间中定位特定内存区域的时候，用的是  红黑树；创建进程fork()、程序载入execve()、映射文件mmap()、动态内存分配malloc()都是分配虚拟内存给进程，这些分配最终都会归结到do_mmap（）函数上，do_mmap判断如果是一个新的空间，则返回vm_area_strcut对象，如果是在某个空间中申请，就合并新内存和老内存。

5、操作系统常用的调度算法
---
（1）批处理作业调度算法
   
   1、先来先服务调度算法（FCFS）  优点公平，缺点短作业饿死
      
   2、短作业优先调度算法(SPF)     长作业不满
     
   3、最高响应比优先算法(HRN)     响应比＝（等待时间＋运行时间）/运行时间，权衡等待时间和运行时间
     
   4、基于优先数调度算法(HPF)     加入优先级
     
   5、均衡调度算法，即多级队列调度算法

（2）进程调度算法

   1、先进先出算法      针对就绪队列中的进程而言，比如一个进程没有拿到锁进入就绪队列中
      
   2、时间片轮转算法     分时系统的一种调度算法
      
   3、最高优先级算法(HPF)   优先级
      
   4、多级队列反馈法
      
（3）虚拟页式存储管理中的页面置换算法
  
   1、先进先出页面置换算法    最早进入内存的页面先失效
     
   2、最近最久未使用算法
      
   3、最少使用算法
   
   
6、进程同步与互斥
---
原子操作、信号量机制、自旋锁管程、会合、分布式系统
7、线程同步的方式
---
（1）临界区  CCriticalSection
```cpp
CcriticalSection g_CriticalSection;
g_CriticalSection.Lock（）；
g_CriticalSection.Unlock（）；
```
（2）信号量
```cpp

```
（3）互斥量
 
（4）条件变量（事件）:通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

8、死锁
---
（1）什么是死锁？死锁产生的条件？

在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。死锁产生的四个条件（有一个条件不成立，则不会产生死锁）
* 互斥条件：一个资源一次只能被一个进程使用
* 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放
* 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺
* 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

（2）死锁的处理策略：

解决死锁的基本方法如下：预防死锁、避免死锁、检测死锁、解除死锁（破坏四个条件之一）

9、动态链接库与静态链接库的区别
---
`1 库是什么`
```cpp
答：库就是一个.o 二进制文件，就是一个加密操作；静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要，动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。
win           linux
.dll             .so    ------->动态库
.lib             .a    --------->静态库
```
`2、静态库的制作`
```cpp
linux下命名规则  libxxx.a   固定前后，中间可以自己写
准备好 a.c  b.c文件
gcc -c *.c -c     //生成.o文件
ar rcs libtest.a  a.o b.o   //打包
num libtest.a    //查看静态库中有几个.o文件

用户调静态库
根据给出的 .h文件写 main.c
gcc main.c -I ./include  -L ./lib  -l test  -o app
          头文件路径   -L静态库路径  -l 静态库名称，去掉lib和.a
gcc ./app 
```
`3、动态库  生成可执行文件`
```cpp
linux下命名规则  libxxx.so
gcc a.c b.c -c -fpic
gcc -shared -o libxxx.so a.o b.o

用户调
gcc main.c -I ./include/ -L ./lib/ -l test -o app
./app
一定要把动态库加入到 环境变量中
export LD_LIBRARY_PATH = 动态库路径。
ldd app   ----->查看文件运行需要的所有库 
```

10、中断与系统调用
---
