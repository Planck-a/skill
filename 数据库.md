
数据库基本语句
===
一 查询操作select
---
1、SELECT ` name` FROM employees;

` `可以把关键字变成普通的字符类型

2、起别名

（1）AS  SELECT lastname AS 姓

 （2）空格  SELECT lastname   姓

3、去重复  distinct,注意只能给一列去重

SELECT DISTINCT department_id FROM employees;

SELECT DISTINCT department_id，firstname FROM employees;  //会报错的！

4、+   只有数值运算功能，没有字符串拼接相关功能

（1）SELECT 1+2;数字相加，显示3

（2）SELECT '123'+1; 转移成功，显示124

（3）SELECT 'abc'+1;转移失败，显示1

（4）SELECT null+1;一方为null，直接返回null

5、拼接函数CONCAT

SELECT CONCAT(lastname,firstname) AS 姓名 FROM employees;

6、判断为空函数IFNULL(字段，输出)

commission_pct字段有null的情况下，下列语句会报错

SELECT CONCAT(lastname,firstname,',',commission_pct) AS output FROM employees;//会报错

SELECT CONCAT(lastname,firstname,',',IFNULL(commission_pct,0)) AS output FROM employees;//null的字段会变成0

SELECT lastname,salary*12*(IFNULL(commission_pct,0)) FROM employees;


二 条件查询操作 where （部分行）
---
查询 "条件" 的员工姓名和部门编号     ‘的’后面就是SELECT后面紧跟的

1、条件运算符 >  <    <=  >=    <> 不等于

2、逻辑运算符  and or not

3、模糊查询  like , between and,in,is null

 （1） like
 
    SELECT * FROM employees WHERE lastname LIKE '%a%';
    like + 通配符：% _    ，_表示只匹配一个
    转移符：如果要匹配第二个字符为_的，LIKE '_ \_%'
    指定转移符：LIKE '_&_' ESCAPE '&'
    
 (2) IN   作用类似于or
 
  SELECT * FROM employees WHERE job_id IN('IT_PORT','AD_VP');
 
 (3)IS NULL
 
 SELECT * FROM employees WHERE commission_pct IS NULL;
 
  SELECT * FROM employees WHERE commission_pct IS NOT NULL;
  
  
 
 
    
     
    























请你说一说数据库索引，多加索引一定好吗？
---

1、索引

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。

DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。

优点：

通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

缺点：

创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

2、添加索引原则

在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

3 什么情况下设置了索引但无法使用？

以“%(表示任意0个或多个字符)”开头的LIKE语句，模糊匹配；

OR语句前后没有同时使用索引；

数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；

对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。

4 索引的类型

主键、自增主键、主键索引与唯一索引概念区别

主键：指字段 唯一、不为空值 的列；

主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；

自增主键：字段类型为数字、自增、并且是主键；

唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。

5 主键和索引有什么区别？

　　主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。


● 请你说一说inner join和left join
---
参考回答：
left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行

● 请你说一说数据库事务
---
参考回答：
对于数据库表进行insert操作后，数据默认是自动提交的，auto-commit，执行一条sql语句后效果立即体现，且不能rollback；事务是说我们先关闭autocommit，等语句执行完后手动commit，而在commit之前是可以回滚的。

开启事务三种方法：begin 或者 start transaction  或者 set autocommit =0；

数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，包括了多条sql语句。这多条语句要么完全地执行成功，要么完全地同时失败。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。

对于不同的事务隔离级别，事务并发带来的问题？？

* 脏读：一个事务读取了另一个事务未提交的数据；

* 不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；

* 幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。

● 请你说一下数据库事务以及四个特性
---
参考回答：
事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。

事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。


1）原子性（Atomicity）

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

2）一致性（Consistency）

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3）隔离性（Isolation）--->Mysq默认的隔离级别为可重复读

同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。

不同的隔离级别：

Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，通常又称为dirty read，什么都不需要做，一个事务可以读到另一个事务未提交的结果，这样可能会提高性能，但是会导致‘脏读’问题；

Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题，该隔离级别不能避免‘不可重复读’问题；

Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。但是会出现‘幻读’。

Serialization（可串行化）：隔离级别最高，只允许事务串行执行，牺牲了系统的并发性，但是可以解决并发事务的所有问题。

4）持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。


● 请你说一说数据库的三大范式
---
参考回答：
（1）第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分

比如一张表：


姓名   地址         电话

谢     中国山西      xxx


第二列中地址可以再分为国家和省市，那么就认为这个表不符合1NF，应再进行投影分解

（2）第二范式：如首先关系模式R要满足第一范式，其次R必须要有主属性，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式

比如：


学号    课程    学院      院长      成绩

001     数学    数学      小王       100


在这张表中，主属性为（学号，课程），根据学号+课程能才得到成绩，但是非主属性 学院-->学号，只知道学号就能得到学院，所以非主属性并不是完全依赖于R的每一个候选关键属性，因此不符合2NF，应分为两个表：

学号    课程       成绩                         学号      学院      院长     
001     数学       100                         001       数学      小王       



（3）第三范式：设R是一个满足第一 二范式条件的关系模式，主属性应全都传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于另一非主属性


比如：

学号      学院      院长

001       数学      小王  


非主属性学院是完全依赖于学号的，没有问题；但是另一非主属性院长是依赖于学院的，是传递依赖于主属性的，那就不满足3NF

MySQL中的悲观锁与乐观锁的实现
---
悲观锁与乐观锁是两种常见的资源并发锁设计思路，也是并发编程中一个非常基础的概念。

(1). 悲观锁

　　悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。通常来讲，在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select … for update时会获取被select中的数据行的行锁，因此其他并发执行的select … for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。

　　这里需要特别注意的是，不同的数据库对select… for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外，mysql还有个问题是: select… for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此，如果在mysql中用悲观锁务必要确定使用了索引，而不是全表扫描。

(2). 乐观锁

　　乐观锁的特点先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号或者时间戳，然后按照如下方式实现：

　　乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这其间没有发生并发的修改。如果更新失败，即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。

(3). 悲观锁与乐观锁的应用场景

　　一般情况下，读多写少更适合用乐观锁，读少写多更适合用悲观锁。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。
  
  文件索引和数据库索引为什么选择B+树
  ---
  1/节点不存储数据，大量存储性
  
  2/局部搜索性
  
 　　文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入，而红黑树这种结构，高度明显要深的多，并且由于逻辑上很近的节点(父子)物理上可能很远，无法利用局部性。最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。
  
  SQL常用语句优先级？
  ---
  from > on> join > where >  group by > with > having > select > distinct  > order by  > limit
  
  
  MySQL中的优化
  ---
  SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化四个方面
  
  * 数据库设计方面
      建立索引
      数据表分区
      尽量使用固定长度的字段
      限制字段长度
      分表，分库

* 数据库I/O方面
        增加缓冲器
        涉及表的级联，不同的表存储在不同的磁盘上，以增加I/O速度
        改善物理设备，比如更换固态硬盘

* 在SQL语句方面

      优化SQL语句，较少比较次数
      限制返回的记录数，进行分页查询
  
  
  NOSQL数据库 —— Redis和mogodb
  ---
  MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？
  ---

