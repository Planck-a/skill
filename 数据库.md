
数据库基本语句
===
一 查询操作select
---
1、SELECT \`name\` FROM employees;

\` \`可以把关键字变成普通的字符类型

2、起别名

（1）AS  SELECT lastname AS 姓

 （2）空格  SELECT lastname   姓

3、去重复  distinct,注意只能给一列去重

SELECT DISTINCT department_id FROM employees;

SELECT DISTINCT department_id，firstname FROM employees;  //会报错的！

4、+   只有数值运算功能，没有字符串拼接相关功能

（1）SELECT 1+2;数字相加，显示3

（2）SELECT '123'+1; 转移成功，显示124

（3）SELECT 'abc'+1;转移失败，显示1

（4）SELECT null+1;一方为null，直接返回null

5、拼接函数CONCAT

SELECT CONCAT(lastname,firstname) AS 姓名 FROM employees;

6、判断为空函数IFNULL(字段，输出)

commission_pct字段有null的情况下，下列语句会报错

SELECT CONCAT(lastname,firstname,',',commission_pct) AS output FROM employees;//会报错

SELECT CONCAT(lastname,firstname,',',IFNULL(commission_pct,0)) AS output FROM employees;//null的字段会变成0

SELECT lastname,salary*12*(IFNULL(commission_pct,0)) FROM employees;


二 条件查询操作 where （部分行）
---
查询 "条件" 的员工姓名和部门编号     ‘的’后面就是SELECT后面紧跟的

1、条件运算符 >  <    <=  >=    <> 不等于

2、逻辑运算符  and or not

3、模糊查询  like , between and,in,is null

 （1） like
```
    SELECT * FROM employees WHERE lastname LIKE '%a%';
    like + 通配符：% _    ，_表示只匹配一个
    转移符：如果要匹配第二个字符为_的，LIKE '_ \_%'
    指定转移符：LIKE '_&_' ESCAPE '&'
 ```
    
 (2) IN   作用类似于or
 
  SELECT * FROM employees WHERE job_id IN('IT_PORT','AD_VP');
 
 (3)IS NULL
 
 SELECT * FROM employees WHERE commission_pct IS NULL;
 
  SELECT * FROM employees WHERE commission_pct IS NOT NULL;
  
  
三、单表里的各种常用的查询
---
1、排序      ORDER BY 

注意 ORDER BY 可以对多列进行联合的排序，比如ORDER BY score DESC, gender,表示先按score列倒序，如果有相同分数的，再按gender列排序

2、显示某几行结果   LIMIT 3 OFFSET 0

需要掌握：

 -   LIMIT 3 OFFSET 0 （可简写为LIMIT 3, 0） ，3指的是每页显示3个，offset表示从第几行开始显示
 
 -    LIMIT 3 ，表示只显示前3个（常用），比如显示班级成绩前3名
 
 3、分组   GROUP BY
 
 4、聚合查询
 
 五个聚合函数必须掌握：总数(SUM)、合计值(SUM)、平均值(AVG)、最大值(MAX)和最小值(MIN)
 
 使用的时候，先不加聚合函数 ，比如 SELECT * num FROM students ;  然后再加上SELECT COUNT(*) num FROM students ，表示对结果进行一个再加工。
 
 注意一点，GROUP BY分组为n组后，再使用聚合函数，那么结果也是会有n行的。  SELECT COUNT(*) num FROM students GROUP BY class_id;

四、多表查询
---
  
  



请你说一说数据库索引，多加索引一定好吗？
---

1、索引

索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。

DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度。索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。

优点：

通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

缺点：

创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

2、添加索引原则

在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

定义为text、image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。

当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

3 什么情况下设置了索引但无法使用？

以“%(表示任意0个或多个字符)”开头的LIKE语句，模糊匹配；

OR语句前后没有同时使用索引；

数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）；

对于多列索引，必须满足 最左匹配原则 (eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)。

4 索引的类型

主键、自增主键、主键索引与唯一索引概念区别

主键：指字段 唯一、不为空值 的列；

主键索引：指的就是主键，主键是索引的一种，是唯一索引的特殊类型。创建主键的时候，数据库默认会为主键创建一个唯一索引；

自增主键：字段类型为数字、自增、并且是主键；

唯一索引：索引列的值必须唯一，但允许有空值。主键是唯一索引，这样说没错；但反过来说，唯一索引也是主键就错误了，因为唯一索引允许空值，主键不允许有空值，所以不能说唯一索引也是主键。

5 主键和索引有什么区别？

　　主键是一种特殊的唯一性索引，其可以是聚集索引，也可以是非聚集索引。在SQLServer中，主键的创建必须依赖于索引，默认创建的是聚集索引，但也可以显式指定为非聚集索引。InnoDB作为MySQL存储引擎时，默认按照主键进行聚集，如果没有定义主键，InnoDB会试着使用唯一的非空索引来代替。如果没有这种索引，InnoDB就会定义隐藏的主键然后在上面进行聚集。所以，对于聚集索引来说，你创建主键的时候，自动就创建了主键的聚集索引。


● 请你说一说inner join和left join
---
参考回答：

left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录 right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
inner join(等值连接) 只返回两个表中联结字段相等的行

● 请你说一说数据库事务
---
参考回答：
对于数据库表进行insert操作后，数据默认是自动提交的，auto-commit，执行一条sql语句后效果立即体现，且不能rollback；事务是说我们先关闭autocommit，等语句执行完后手动commit，而在commit之前是可以回滚的。

开启事务三种方法：begin 或者 start transaction  或者 set autocommit =0；

数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，包括了多条sql语句。这多条语句要么完全地执行成功，要么完全地同时失败。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。

对于不同的事务隔离级别，事务并发带来的问题？？

* 脏读：一个事务读取了另一个事务未提交的数据；

* 不可重复读：不可重复读的重点是修改，同样条件下两次读取结果不同，也就是说，被读取的数据可以被其它事务修改；

* 幻读：幻读的重点在于新增或者删除，同样条件下两次读出来的记录数不一样。

● 请你说一下数据库事务以及四个特性
---
参考回答：
事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。

事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。


1）原子性（Atomicity）

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

2）一致性（Consistency）

一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。

拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3）隔离性（Isolation）--->Mysq默认的隔离级别为可重复读

同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。

不同的隔离级别：

Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，通常又称为dirty read，什么都不需要做，一个事务可以读到另一个事务未提交的结果，这样可能会提高性能，但是会导致‘脏读’问题；

Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题，该隔离级别不能避免‘不可重复读’问题；

Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。但是会出现‘幻读’。

Serialization（可串行化）：隔离级别最高，只允许事务串行执行，牺牲了系统的并发性，但是可以解决并发事务的所有问题。

4）持久性（Durability）

持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。


● 请你说一说数据库的三大范式
---
参考回答：
（1）第一范式：当关系模式R的所有属性都不能再分解为更基本的数据单位时，称R是满足第一范式，即属性不可分

比如一张表：


姓名   地址         电话

谢     中国山西      xxx


第二列中地址可以再分为国家和省市，那么就认为这个表不符合1NF，应再进行投影分解

（2）第二范式：如首先关系模式R要满足第一范式，其次R必须要有主属性，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式

比如：


学号    课程    学院      院长      成绩

001     数学    数学      小王       100


在这张表中，主属性为（学号，课程），根据学号+课程能才得到成绩，但是非主属性 学院-->学号，只知道学号就能得到学院，所以非主属性并不是完全依赖于R的每一个候选关键属性，因此不符合2NF，应分为两个表：

学号    课程       成绩                         学号      学院      院长     
001     数学       100                         001       数学      小王       



（3）第三范式：设R是一个满足第一 二范式条件的关系模式，主属性应全都传递依赖于R的任意一个候选关键字，称R满足第三范式，即非主属性不传递依赖于另一非主属性


比如：

学号      学院      院长

001       数学      小王  


非主属性学院是完全依赖于学号的，没有问题；但是另一非主属性院长是依赖于学院的，是传递依赖于主属性的，那就不满足3NF

锁及粒度
---
- 共享锁/读锁：互不阻塞，优先级低
- 排他锁/写锁：阻塞其他锁，优先级高，即确保在一个事务写入时不受其他事务的影响。
- 锁粒度：锁定的数据量越少（粒度越小），并发程度越高，但相应的加锁、检测锁、释放锁用的系统开销也随之增大。
- 锁策略：锁开销与数据安全性之间的平衡
     -     表锁：锁住整张表，读锁互不阻塞，写锁阻塞其他所有读写锁（同一张表）。开销最小。
     -     行级锁：对每一行数据（记录）加锁，开销大，并发程度高。



MySQL中的悲观锁与乐观锁的实现
---
悲观锁与乐观锁是两种常见的资源并发锁设计思路，也是并发编程中一个非常基础的概念。

(1). 悲观锁

　　悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为所有的操作均会导致并发安全问题，因此要先确保获取锁成功再进行业务操作。通常来讲，在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select … for update时会获取被select中的数据行的行锁，因此其他并发执行的select … for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。

　　这里需要特别注意的是，不同的数据库对select… for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外，mysql还有个问题是: select… for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此，如果在mysql中用悲观锁务必要确定使用了索引，而不是全表扫描。

(2). 乐观锁

　　乐观锁的特点先进行业务操作，只在最后实际更新数据时进行检查数据是否被更新过，若未被更新过，则更新成功；否则，失败重试。乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号或者时间戳，然后按照如下方式实现：

　　乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这其间没有发生并发的修改。如果更新失败，即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。

(3). 悲观锁与乐观锁的应用场景

　　一般情况下，读多写少更适合用乐观锁，读少写多更适合用悲观锁。乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能。
  
B+树索引和哈希索引
---
- B+树索引：在B-tree上改进得到，其非叶子节点均为key值，叶子节点是key-data键值对。叶子节点前后相连且有序。
- 哈希索引：通过对key进行hash(crc/MD5/sha1/sha256...)而将记录存储在不同的bucket种，可以做到常数时间的查找，但要注意哈希冲突的避免（链表法、线性探测、二次探测、公共溢出区的方法）。其中MD5 128位，和sha1/256码都较长不太适合作为hash函数。默认无序。

    为什么有了B+树索引还要hash索引？
    
- B+树默认有序，hash默认无序，所以哈希索引无法用于排序；
- 哈希索引O(1)在速度上毋庸置疑要快于B+树近似O(logn);对于某些场景如热点页/活跃查询页，需要借助哈希索引来实现快速查询。
- 哈希索引只能进行等值查询（因为他要计算hash(key)再去匹配）而B+树索引可以进行等值、部分前缀、范围查询；
- 底层实现结构不同：B+树是非线性结构，hash桶是线性结构。
        

文件索引和数据库索引为什么选择B+树?  为什么说B+树比B树更适合在操作系统的文件索引和数据库索引？
  ---

（1) B+tree的磁盘读写代价更低（树低）

为了减少I0次数，一个节点设计成占用内存的一个页，所以希望这个页能存储更多的数据。B+tree的内部结点不存储数据，只是一些指针，用来标定到叶节点的路径。由于不放数据了，所以同一个节点能存放的指针也更多，那么相当一个盘块所能容纳的指针数量也越多。相对来说IO读写次数也就降低了。

（2）B+tree的查询效率更加稳定（稳定）

由于只有叶子节点才能存储关键字（文件内容），非叶子结点不存储关键字，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

（3）B+树基于范围查找（范围查询）

由于数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。正是为了解决这个问题，B+树应运而生。B+树所有叶子节点是链接成链表的，只要遍历叶子节点就可以实现整棵树的遍历。比如我们已经查到15这个叶节点了，只要沿着链表向左右走就能查到下一个节点。而且一个盘块中放了多个叶节点，所以同一次I/O之下就可以得出多个节点值。

  
  SQL常用语句优先级？
  ---
  from > on> join > where >  group by > with > having > select > distinct  > order by  > limit
  
  
  MySQL中的优化
  ---
  SQL语句及索引的优化、数据表结构的优化、系统配置的优化和硬件的优化四个方面
  
  * 数据库设计方面
     - 建立索引
     - 数据表分区
     - 尽量使用固定长度的字段
     - 限制字段长度
     - 分表，分库

* 数据库I/O方面
     - 增加缓冲器
     - 涉及表的级联，不同的表存储在不同的磁盘上，以增加I/O速度
     - 改善物理设备，比如更换固态硬盘

* 在SQL语句方面

     - 在经常性的检索列上，建立必要索引，以加快搜索速率，避免全表扫描（索引覆盖扫描）；
     - 多次查询同样的数据，可以考虑缓存该组数据；
      -     - 审视select * form tables, 你需要所有列数据吗？
     - 切分查询（大查询切分成为小查询，避免一次性锁住大量数据）
     - 分解关联查询（单表查询，结果在应用程序中进行关联，可以减少处理过程中的锁争用）
     - 尽量先做单表查询；
  
  
NOSQL数据库 —— Redis和mogodb
  ---
  
MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别？
  ---

    InnoDB,最为通用/推荐的一种引擎，支持事务、行级锁、甚至间隙锁（避免幻读）、支持热备份，MVCC，在并发上占优势，系统资源占用多。

    MyISAM,默认的存储引擎，不支持事务和行级锁，只支持表锁，某些场景性能很好：占用存储上优，查询速度上完胜（大概是InnoDB的3倍）系统资源占用少。

    InnoDB支持事务, MyISAM不支持；

    InnoDB支持行级锁、表锁；MyISAM只支持表锁；

    InnoDB支持MVCC，MyISAM不支持；

    InnoDB不支持全文索引，MyISAM支持；

    InnoDB支持外键，MyISAM不支持外键；

    InnoDB和MyISAM都支持B+树索引，InnoDB还支持自适应哈希索引

    MyISAM实现了前缀压缩技术，占用存储空间更小（但会影响查找），InnoDB是原始数据存储，占用存储更大。

    PS：大部分情况下，InnoDB都是正确的选择。---《高性能MySQL》

  
InnoDB MVCC
  ---
多版本并发控制，是为了避免加锁而实现的。一般的实现方法是存储快照来实现的。InnoDB实现方式是在记录后添加两个隐藏列（表项），分别是事务创建时间、过期时间，存储的实际上是系统版本号（系统版本号随着事务的创建而递增）。
这样一来，INSERT 时加上开始版本号，UPDATE/DELETE时加上过期版本号，这样一来在SELETE时，就只访问开始系统版本号小于当前的事务的版本号、过期时间要么未定义要么在当前版本号之后的记录，这样就可以保证：访问的记录是在本事务开始前就存在而且在本事务期间没有过期（被删除或被修改过的）。可以避免脏读、不可重复读、幻读的问题。

索引
---
主键索引、唯一索引，全文索引，普通索引

索引的分类：mysql的索引分为单列索引(全文索引，主键索引，唯一索引，普通索引)和组合索引。

- 单列索引:一个索引只包含一个列，一个表可以有多个单列索引。

- 组合索引:一个组合索引包含两个或两个以上的列，

